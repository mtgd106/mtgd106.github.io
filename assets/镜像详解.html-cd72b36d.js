import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as t,a as e}from"./app-a89b456a.js";const a="/assets/image-20231105165955472-7621fa4e.png",s="/assets/image-20230426095740561-70195b5f.png",n={},i=e('<h2 id="镜像详解" tabindex="-1"><a class="header-anchor" href="#镜像详解" aria-hidden="true">#</a> 镜像详解</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>​ <strong>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。</strong></p><p>​ <strong>它包含运行某个软件所需要的所有东西，包括代码、运行时、库、环境变量和配置文件等。</strong></p><p>​ 只有通过这个镜像文件才能生成Docker容器实例。</p><h3 id="分层的镜像" tabindex="-1"><a class="header-anchor" href="#分层的镜像" aria-hidden="true">#</a> 分层的镜像</h3><p>以pull为例，在下载的过程中可以看到docker的镜像好像是在一层一层的在下载。</p><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="unionfs" tabindex="-1"><a class="header-anchor" href="#unionfs" aria-hidden="true">#</a> UnionFS</h3><p>UnionFS(联合文件系统) 是一种分层、轻量级并且高性能的文件系统，它支持<strong>将对文件系统的修改作为一次提交来</strong></p><p><strong>一层层的叠加</strong>，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><p><strong>联合文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</strong></p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，</p><p>​   这样最终的文件系统会包含所有底层的文件和目录。</p><h3 id="docker镜像加载原理" tabindex="-1"><a class="header-anchor" href="#docker镜像加载原理" aria-hidden="true">#</a> Docker镜像加载原理</h3><p>​ <strong>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。</strong></p><h4 id="bootfs" tabindex="-1"><a class="header-anchor" href="#bootfs" aria-hidden="true">#</a> <strong>bootfs</strong></h4><p>​ bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载</p><p>​ bootfs文件系统，<strong>在Docker镜像的最底层就是引导文件系统bootfs。</strong></p><p>​ 这一层与典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了。</p><p>​ 此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><h4 id="rootfs" tabindex="-1"><a class="header-anchor" href="#rootfs" aria-hidden="true">#</a> <strong>rootfs</strong></h4><p>​ rootfs(root file system)，在bootfs之上，包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。</p><p>​ rootfs就是各种不同的操作系统发行版， 比如Ubuntu，Centos等等。</p><p>​ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用</p><p>​ Host的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，</p><p>​ rootfs会有差别，因此不同的发行版可以共用bootfs。</p><h4 id="原因" tabindex="-1"><a class="header-anchor" href="#原因" aria-hidden="true">#</a> <strong>原因</strong></h4><ol><li><p><strong>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</strong></p><p>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；</p><p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且<strong>镜像的每一层都可以被共享</strong>。</p></li><li><p><strong>docker镜像层都是只读的，容器层是可写的。</strong></p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，&quot;容器层&quot;之下的都叫“镜像层”。</p><p>所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。</p></li></ol><p>​ <img src="'+s+'" alt="image-20230426095740561" loading="lazy"></p><h3 id="commit操作" tabindex="-1"><a class="header-anchor" href="#commit操作" aria-hidden="true">#</a> commit操作</h3><p>  docker commit  </p><p>    <strong>将修改过的容器提交使之成为一个新的镜像</strong></p><p>    我们可以在生成的容器中做一些修改，比如配置dhcp、配置apache，把修改过的容器当做一个模板上传，那么别人用</p><p>    这个模板生成的容器就会已经配置好了dhcp和apache。</p><p>  具体使用：</p><p>   docker commit -a &quot;作者名&quot; -m &quot;描述信息&quot; +当前操作的容器ID +要创建的目标镜像名:[标签名]</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><strong>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像</strong>。类似Java继承于一个Base基础类，自己再按需扩展。</p><p><strong>新镜像是从 base 镜像一层一层叠加生成的</strong>。每安装一个软件，就在现有镜像的基础上增加一层。</p>',40),p=[i];function d(h,c){return r(),t("div",null,p)}const l=o(n,[["render",d],["__file","镜像详解.html.vue"]]);export{l as default};
