import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,a as s}from"./app-a89b456a.js";const i="/assets/image-20230426095752374-7531f2ec.png",l="/assets/image-20230426095804965-3ec43b3f.png",t={},r=s('<h3 id="镜像结构" tabindex="-1"><a class="header-anchor" href="#镜像结构" aria-hidden="true">#</a> 镜像结构</h3><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>镜像是分层的结构，每一层称为一个Layer</p><ul><li><p>BaseImage层：包含基本的系统函数库、环境变量、文件系统</p></li><li><p>Entrypoint：入口，是镜像中应用启动的命令</p></li><li><p>其它：在BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置</p></li></ul><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p><strong>Dockerfile ---镜像的描述文件，是用来构建Docker镜像的文本文件，是由一系列构建镜像所需的命令和参数构成的脚本。</strong></p><h4 id="构建步骤" tabindex="-1"><a class="header-anchor" href="#构建步骤" aria-hidden="true">#</a> <strong>构建步骤：</strong></h4><ol><li><p>编写Dockefile文件</p></li><li><p>使用docker build 命令构建镜像</p></li><li><p>使用新生成的镜像，创建新的容器</p></li></ol><h4 id="dockerfile内容" tabindex="-1"><a class="header-anchor" href="#dockerfile内容" aria-hidden="true">#</a> <strong>Dockerfile内容</strong></h4><ol><li><p>每条保留字指令都必须为大写字母且后面要至少跟一个参数</p></li><li><p>指令按照从上到下，顺序执行</p></li><li><p><code>#</code>表示注释</p></li><li><p>每条指令都会创建一个新的镜像层，并对镜像进行提交</p></li></ol><h4 id="docker执行dockerfile的大致流程" tabindex="-1"><a class="header-anchor" href="#docker执行dockerfile的大致流程" aria-hidden="true">#</a> <strong>Docker执行Dockerfile的大致流程</strong></h4><ol><li><p>docker从基础镜像运行一个容器</p></li><li><p>执行一条指令并对容器做出修改</p></li><li><p>执行类似docker commit 的操作提交一个新的镜像层</p></li><li><p>docker 再基于刚提交的镜像运行一个新的容器</p></li><li><p>执行dockerfile中的下一条指令直到所有的指令都执行完成</p></li></ol><h3 id="关系" tabindex="-1"><a class="header-anchor" href="#关系" aria-hidden="true">#</a> 关系</h3><ol><li><p>Dockerfile</p><p>Dockerfile定义了进程需要的一切东西。</p><p>Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版本</p><p>服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制);</p></li><li><p>Docker镜像</p><p>在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行Docker镜像时，会真正开始提供服务</p></li><li><p>Docker容器：容器是直接提供服务的。</p></li></ol><h3 id="保留字指令" tabindex="-1"><a class="header-anchor" href="#保留字指令" aria-hidden="true">#</a> 保留字指令</h3><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>FROM</td><td>基础镜像，当前新镜像是基于哪个镜像的。指定一个已经存在的镜像作为模板，<strong>文件第一条必须是FROM</strong>。</td></tr><tr><td>MAINTAINER</td><td>镜像维护者的姓名和邮箱地址</td></tr><tr><td>RUN</td><td>容器创建时需要执行的命令, <strong>RUN是在 docker build时运行</strong><br>1.shell格式   RUN &lt;命令行命令&gt; 等同于在shell终端操作的shell命令 例：RUN yum -y install vim<br>2.exec格式   RUN [&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;]</td></tr><tr><td>EXPOSE</td><td>当前容器对外暴露的端口号</td></tr><tr><td>WORKDIR</td><td>指定 在创建容器后，终端登录进来后默认的工作目录</td></tr><tr><td>ENV</td><td>在创建容器的过程中设置环境变量<br>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样</td></tr><tr><td>ADD</td><td>将本机目录下的文件拷贝进镜像，且ADD命令会自动处理URL命令和解压tar压缩包<br> ADD  本机路径   容器路径 或 ADD  [&quot;本机路径&quot;,&quot;容器路径&quot;]</td></tr><tr><td>COPY</td><td>类似ADD，拷贝文件和目录到镜像中(可以重命名)<br> COPY  本机路径  容器路径 或 COPY [&quot;本机路径&quot;,&quot;容器路径&quot;]</td></tr><tr><td>VOLUME</td><td>容器数据卷，用于数据保持和持久化工作</td></tr><tr><td>CMD</td><td>指定一个容器启动时第一个运行的命令及其参数，dockerfile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run命令最后的输入参数替换<br><strong>CMD是在docker run 时运行</strong></td></tr><tr><td>ENTRYROINT</td><td>指定一个容器启动时第一个运行的命令及其参数，但CMD指令会被覆盖，而ENTRYPOINT则是追加</td></tr><tr><td>ONBUILD</td><td>当创建一个继承父镜像的镜像时运行该命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发</td></tr></tbody></table><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> <strong>分类：</strong></h4><figure><img src="'+i+`" alt="image-20230426095752374" tabindex="0" loading="lazy"><figcaption>image-20230426095752374</figcaption></figure><p>​</p><h3 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h3><p>Base镜像(scratch)：Docker Hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的。</p><p><strong>过程：</strong></p><ol><li><p>在本机创建一个dockerfile文件</p></li><li><p>根据需要使用保留字指令编辑该文件</p></li><li><p>以该文件为模板生成新的镜像</p></li><li><p>使用新的镜像创建新的容器</p></li></ol><p>例：编辑自己的centos7镜像，使其具备vim+ifconfig+jdk8</p><ol><li>编辑DockerFile文件</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>FROM centos

MAINTAINER vkls<span class="token operator">&lt;</span>vkls@126.com<span class="token operator">&gt;</span>
 
ENV MYPATH /usr/local

WORKDIR <span class="token variable">$MYPATH</span>
 
<span class="token comment">#安装vim编辑器</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>

<span class="token comment">#安装ifconfig命令查看网络IP</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> net-tools

<span class="token comment">#安装java8及lib库</span>
RUN yum <span class="token parameter variable">-y</span> <span class="token function">install</span> glibc.i686
RUN <span class="token function">mkdir</span> /usr/local/java

<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>
ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/

<span class="token comment">#配置java环境变量</span>
ENV JAVA_HOME /usr/local/java/jdk1.8.0_171
ENV JRE_HOME <span class="token variable">$JAVA_HOME</span>/jre
ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span>
ENV <span class="token environment constant">PATH</span> <span class="token variable">$JAVA_HOME</span>/bin:<span class="token environment constant">$PATH</span>
 
EXPOSE <span class="token number">80</span>
 
CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>

CMD <span class="token builtin class-name">echo</span> <span class="token string">&quot;success--------------ok&quot;</span>

CMD /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>构建</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> build <span class="token parameter variable">-f</span> +dockfile文件路径 <span class="token parameter variable">-t</span> +新镜像名称:tag <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>运行</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-it</span> +新镜像名称:tag  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="虚悬镜像" tabindex="-1"><a class="header-anchor" href="#虚悬镜像" aria-hidden="true">#</a> 虚悬镜像</h3><p>定义：仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称dangling image</p><p>查看：docker image ls -f dangling=true</p><p>删除：docker image prune</p><figure><img src="`+l+'" alt="image-20230426095804965" tabindex="0" loading="lazy"><figcaption>image-20230426095804965</figcaption></figure>',35),d=[r];function o(c,p){return e(),n("div",null,d)}const b=a(t,[["render",o],["__file","DockerFile.html.vue"]]);export{b as default};
