import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as p,c as r,f as n,a as e}from"./app-a89b456a.js";const t="/assets/image-20230426101701909-b9ae9153.png",i="/assets/image-20230426101710141-f0d1f8e8.png",s="/assets/image-20230426101722078-91ba792d.png",o="/assets/image-20230426101734598-96c1c173.png",l="/assets/image-20230426101748904-0a3ff45a.png",d="/assets/image-20230426101759064-262097be.png",g="/assets/image-20230426101832222-c799429f.png",h="/assets/image-20230426101839145-1ca3d95a.png",c="/assets/image-20230426101845453-f3d2d734.png",u="/assets/image-20230426101856937-6b9d8e5e.png",m="/assets/image-20230426101908481-1fd0984f.png",v="/assets/image-20230426101917846-ad8f73f1.png",b="/assets/image-20230426101926269-6a5f70bd.png",f="/assets/image-20230426101933561-7beb5579.png",x="/assets/image-20230426101959784-1f7f4212.png",J="/assets/image-20230426102005803-1c8e4b85.png",M="/assets/image-20230426102013256-47c939bc.png",_="/assets/image-20230426102023685-b54b6043.png",C="/assets/image-20230426102042447-58d1bb97.png",y="/assets/image-20230426102050253-8feb0352.png",G="/assets/image-20230426102059056-ea8fe6d0.png",X="/assets/image-20230426102146599-fbf2ae09.png",k="/assets/image-20230426102204688-48700676.png",V="/assets/image-20230426102235087-ca7e1cf7.png",S="/assets/image-20230426102255172-07030267.png",j="/assets/image-20230426102311679-330cc0bb.png",E={},z=e('<h1 id="运行时内存空间" tabindex="-1"><a class="header-anchor" href="#运行时内存空间" aria-hidden="true">#</a> 运行时内存空间</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p><strong>运行时数据区：</strong></p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>运行时数据区完整图：</strong></p><p>​ <img src="'+i+'" alt="" loading="lazy"></p><h3 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h3><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p><p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。</p><p>Java线程执行终止后，本地线程也会被回收。</p><h3 id="线程独有和共享" tabindex="-1"><a class="header-anchor" href="#线程独有和共享" aria-hidden="true">#</a> 线程独有和共享</h3><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出</p><p>而销毁。(一个虚拟机的启动代表一个进程的开始)。</p><p>另外一些则是与线程一一对应的， 这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。</p><p>即：</p><ul><li><p><strong>线程独有：程序计数器、虚拟机栈、本地方法栈。</strong></p></li><li><p><strong>线程共享：堆、堆外内存(永久代或元空间、代码缓存)</strong></p></li></ul><h3 id="jvm-系统线程" tabindex="-1"><a class="header-anchor" href="#jvm-系统线程" aria-hidden="true">#</a> JVM 系统线程</h3><p>如果使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。</p><p>这些后台线程不包括调用 public static void main(String[])方法的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li><p><strong>虚拟机线程</strong>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是它们</p><p>  都需要 JVM 达到安全点，这样堆才不会变化。</p><p>  这种线程的类型包括&quot;stop-the-world&quot;的垃圾收集，线程栈收集， 线程挂起以及偏向锁撤销。</p></li><li><p><strong>周期任务线程</strong>：这种线程是时间周期事件的体现(比如中断)，它们一般用于周期性操作的调度执行。</p></li><li><p><strong>GC 线程</strong>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</p></li><li><p><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码。</p></li><li><p><strong>信号调度线程</strong>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</p></li></ul><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在 JVM 规范中，<strong>每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</strong>。</p><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p><strong>PC 寄存器用来存储指向下一条指令的地址。由执行引擎读取下一条指令。</strong></p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p><p>任何时间一个线程都只有一个方法在执行，即，当前方法。<strong>程序计数器会存储当前线程正在执行的方法的指令地址；</strong></p><p>  或者，如果是在执行 native 方法，则是未指定值(undefned)。</p><p>它是唯一一个在 Java 虚拟机规范中<strong>没有规定任何 outofMemoryError 情况</strong>的区域。</p><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈" aria-hidden="true">#</a> 虚拟机栈</h2><h4 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1" aria-hidden="true">#</a> <strong>定义</strong></h4><p> Java 虚拟机栈(Java Virtual Machine Stack)，早期也叫 Java 栈。</p><p> 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的 Java 方法调用。</p><p> <strong>虚拟机栈是线程私有的；生命周期和线程一致，线程结束，虚拟机栈销毁。栈不存在垃圾回收的问题。</strong></p><h4 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1" aria-hidden="true">#</a> <strong>作用</strong></h4><p><strong>主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回</strong></p><h4 id="栈与堆的区别" tabindex="-1"><a class="header-anchor" href="#栈与堆的区别" aria-hidden="true">#</a> <strong>栈与堆的区别</strong></h4><p>栈是运行时的单位，而堆是存储的单位</p><ul><li><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</p></li><li><p>堆解决的是数据存储的问题，即数据怎么放，放哪里</p></li></ul><h4 id="栈中可能出现的异常" tabindex="-1"><a class="header-anchor" href="#栈中可能出现的异常" aria-hidden="true">#</a> <strong>栈中可能出现的异常</strong></h4><p>Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。</p><p><strong>如果线程请求分配的栈容量超过允许的最大容量，Java 虚拟机将会抛出一个 StackoverflowError 异常</strong>。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且<strong>在尝试扩展的时候无法申请到足够的内存</strong>， 或者<strong>在创建新的线程时没有足够的</strong></p><p><strong>内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个outofMemoryError 异常。</strong></p></li></ul><h4 id="设置栈内存大小" tabindex="-1"><a class="header-anchor" href="#设置栈内存大小" aria-hidden="true">#</a> <strong>设置栈内存大小</strong></h4><p>可以使用参数 -Xss 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><p>​  -Xss  1m</p><p>​  -Xss  1k</p><h2 id="栈帧" tabindex="-1"><a class="header-anchor" href="#栈帧" aria-hidden="true">#</a> 栈帧</h2><h3 id="概述-1" tabindex="-1"><a class="header-anchor" href="#概述-1" aria-hidden="true">#</a> 概述</h3><h4 id="栈的存储单位" tabindex="-1"><a class="header-anchor" href="#栈的存储单位" aria-hidden="true">#</a> <strong>栈的存储单位</strong></h4><p>每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在。</p><p><strong>在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)。</strong></p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><p>​ <img src="'+s+'" alt="image-20230426101722078" loading="lazy"></p><h4 id="栈的运行原理" tabindex="-1"><a class="header-anchor" href="#栈的运行原理" aria-hidden="true">#</a> <strong>栈的运行原理</strong></h4><p> <strong>不同线程中所包含的栈帧是不允许相互引用的，即，不能在一个栈帧之中引用另外一个线程的栈帧。</strong></p><p> 如果当前方法调用了其他方法，方法返回之时，当前栈帧会传回此方法的执行结果给前一个栈帧(存放在操作数栈中)，</p><p>   接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p> Java 方法有两种函数返回的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。</p><p>   不管使用哪种方式，都会导致栈帧被弹出。</p><h4 id="栈帧的内部结构" tabindex="-1"><a class="header-anchor" href="#栈帧的内部结构" aria-hidden="true">#</a> <strong>栈帧的内部结构</strong></h4><p>每个栈帧中存储着：</p><p>​ • 局部变量表(Local Variables)</p><p>​ • 操作数栈(operand Stack)(或表达式栈)</p><p>​ • 动态链接(DynamicLinking)(或指向运行时常量池的方法引用)</p><p>​ • 方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</p><p>​ • 一些附加信息</p><p>​ <img src="'+o+'" alt="image-20230426101734598" loading="lazy"></p><p>  <strong>栈帧的大小主要由局部变量表和操作数栈决定</strong></p><h3 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> 局部变量表</h3><p> 局部变量表(Local Variables)，又称之为局部变量数组或本地变量表。</p><p> 定义为一个数字数组，<strong>主要用于存储方法参数和定义在方法体内的局部变量。</strong></p><p> 这些数据类型包括各类基本数据类型、对象引用(reference)，以及 returnAddress 类型。</p><p> 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong>。</p><p> <strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的 Code 属性的maximum local variables 数据项中。</p><p> <strong>方法运行期间不会改变局部变量表的大小。</strong></p><h5 id="关于slot的理解" tabindex="-1"><a class="header-anchor" href="#关于slot的理解" aria-hidden="true">#</a> <strong>关于Slot的理解</strong></h5><p> 在局部变量表中，最基本的存储单元是 Slot(变量槽)</p><p> 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress 类型的变量。</p><p>   <code>returnAddress</code> 是一个表示函数返回地址的数据类型，用于指示程序在函数调用结束后应继续执行的位置。</p><p>​ 在局部变量表里，<strong>32位以内的类型只占用一个slot(包括 returnAddress 类型)，64位的类型(long 和 double)占用两个 slot,</strong></p><p>​ <strong>byte、short、char 在存储前被转换为 int；boolean 也被转换为 int，0 表示 false，非 0 表示 true。</strong></p><p>​ <img src="'+l+'" alt="image-20230426101748904" loading="lazy"><br> ​</p><p> 参数值的存放从局部变量数组的 index0 开始，到数组长度-1 的索引处结束。</p><p> JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值。</p><p> 当一个实例方法被调用的时候，它的参数和方法内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个</p><p>   slot 上，如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可。</p><p> 如果当前栈帧是由构造方法或者实例方法(非静态方法)创建的，那么该对象的引用 this 指针将会存放在index 为 0</p><p>   的 slot 处，其余的参数按照参数表顺序继续排列。</p><figure><img src="'+d+`" alt="image-20230426101759064" tabindex="0" loading="lazy"><figcaption>image-20230426101759064</figcaption></figure><h5 id="slot的重复使用" tabindex="-1"><a class="header-anchor" href="#slot的重复使用" aria-hidden="true">#</a> <strong>Slot的重复使用</strong></h5><p> 栈帧中的局部变量表中的槽位是可以重复使用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的</p><p>  局部变量就很有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。</p><h5 id="静态变量与局部变量的对比" tabindex="-1"><a class="header-anchor" href="#静态变量与局部变量的对比" aria-hidden="true">#</a> <strong>静态变量与局部变量的对比</strong></h5><ul><li><p>按数据类型分：基本数据类型、引用数据类型</p></li><li><p>按在类中声明的位置分：成员变量(又分为类变量，实例变量)、局部变量</p><ul><li><p>类变量：在linking 的 preparation准备阶段，给类变量默认赋值，initial 阶段给类变量显式赋值。</p></li><li><p>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值。</p></li><li><p>局部变量：在使用前必须进行显式赋值即人为初始化，否则编译不通过。</p></li></ul></li></ul><p>​ <strong>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</strong></p><p>​ <strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</strong></p><h3 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈" aria-hidden="true">#</a> 操作数栈</h3><p>定义：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)和 出栈(pop)</p><ul><li><p><strong>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</strong></p></li><li><p>操作数栈就是JVM 执行引擎的一个工作区，<strong>当一个方法开始执行时，一个新的栈帧也会被创建出来</strong>，这个方法的</p><p>  操作数栈是空的，这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，<strong>其所需的最大深度在编译期就定义好了</strong>，保存在</p><p>  方法的 Code 属性中，为 max_stack 的值。</p><p>  栈中的任何一个元素都可以是任意的 Java 数据类型</p></li></ul><p>​      • <strong>32bit 的类型占用一个栈单位深度</strong></p><p>​      • <strong>64bit 的类型占用两个栈单位深度</strong></p><ul><li><p>操作数栈不能通过访问索引的方式来进行数据访问，只能通过标准的入栈和出栈操作来完成一次数据访问。</p></li><li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器。</strong></p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p><strong>Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</strong></p></li></ul><p>​ 代码示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAddOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   
      <span class="token keyword">byte</span> i <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
				   
      <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
				   
      <span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>             
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>   先对代码进行编译，然后使用javap命令反编译class文件：javap -v 类名.class</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public void testAddOperation();
             			Code:
                  0:bipush            15
                  2:istore_1
                  3:bipush             8
                  5:istore_2
                  6:iload_1         
                  7:iload_2
                  8:iadd
                  9:istore_3
                  10:return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p> <strong>执行过程如下：</strong></p><p>​ 首先执行第一条语句，PC 寄存器中的值是 0，也就是指令地址为 0，然后使用bipush 让操作数 15 入栈。</p><p>​ <img src="`+g+'" alt="image-20230426101832222" loading="lazy"></p><p>​ 执行完后，让 PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表 1 的位置，(0的位置存放的<br> ​ 是this)<br> ​ <img src="'+h+'" alt="image-20230426101839145" loading="lazy"></p><p>​ <img src="'+c+'" alt="image-20230426101845453" loading="lazy"><br> ​ <img src="'+u+'" alt="image-20230426101856937" loading="lazy"></p><p>​ 然后要执行两个局部变量相加的操作，所以再依次将数据放在操作数栈中<br> ​ <img src="'+m+'" alt="image-20230426101908481" loading="lazy"></p><p>​ iload_1:加载局部变量表中索引为1处的数据(int类型)<br> ​ <img src="'+v+'" alt="image-20230426101917846" loading="lazy"></p><p>​ 然后将操作数栈中的两个元素执行相加操作，并将结果存储在局部变量表中索引为3 的位置<br> ​ <img src="'+b+'" alt="image-20230426101926269" loading="lazy"></p><p>​  <strong>byte、short、char、boolean 类型在内部都是使用 int 型来进行保存的</strong></p><p>​  最后，方法返回。<br> ​</p><h3 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h3><p>动态链接(又称 指向运行时常量池的方法引用，因为运行时常量池是放在方法区的)</p><ul><li><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用(一个指向该栈帧所属方法的地址)</p><p>包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如：invokedynamic 指令</p></li><li><p><strong>当Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用(即，地址 symbolic Reference)保存在</strong></p><p><strong>class文件的常量池中。</strong></p></li></ul><p>​  比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用(一个指向方法的指针)来表示的，</p><p>​    那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用(即，真实地址)。</strong><br> ​ <img src="'+f+'" alt="image-20230426101933561" loading="lazy"></p><h5 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用" aria-hidden="true">#</a> <strong>方法的调用</strong></h5><p>​ 在 JVM 中，可以将符号引用转换为调用方法的直接引用，这个过程与方法的绑定机制相关。</p><h4 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> <strong>链接</strong></h4><p><strong>静态链接</strong></p><p>当一个字节码文件被装载进 JVM 内部时，如果<strong>被调用的目标方法在编译期可知， 且运行期保持不变时</strong>，这种情况下</p><p>将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p><p><strong>动态链接</strong></p><p>如果<strong>被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用的方法的符号引用转换为直接引用，</p><p>由于这种引用的转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="绑定机制" tabindex="-1"><a class="header-anchor" href="#绑定机制" aria-hidden="true">#</a> <strong>绑定机制</strong></h4><p>​ 对应的方法的绑定机制为：早期绑定(Early Binding)和晚期绑定(Late Binding)。</p><p>​ <strong>绑定是 一个字段、方法或者类 的符号引用被替换为直接引用的过程， 这个过程仅发生一次。</strong></p><p><strong>早期绑定</strong></p><p>​  早期绑定是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，</p><p>  这样一来，由于明确了被调用的目标方法是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><p><strong>晚期绑定</strong></p><p>  如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，</p><p>    这种绑定方式也就被称之为晚期绑定。</p><h4 id="虚方法和非虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法和非虚方法" aria-hidden="true">#</a> <strong>虚方法和非虚方法</strong></h4><ul><li><p><strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</strong></p></li><li><p><strong>静态方法、私有方法、final 方法、实例构造器、在子类中被调用的父类方法(使用super.方法名调用)都是非虚方法。</strong></p></li></ul><p>​     因为这些方法都不能被重写。如果方法可以被重写，那么在编译期间就无法确定调用的是哪个版本的方法。</p><ul><li><p>其他方法称为虚方法。</p></li><li><p>如果在一个类中调用该类的公有方法(public修饰)，则该方法就属于虚方法，因为这个方法可能被该类的子类重写。</p><p>  如果该类的这个公有方法在其子类中被调用(通过super关键字)，这时该方法就属于非虚方法。</p></li></ul><h3 id="方法返回地址" tabindex="-1"><a class="header-anchor" href="#方法返回地址" aria-hidden="true">#</a> 方法返回地址</h3><p><strong>存放调用当前方法的方法的PC寄存器的值，当 当前方法执行完后，通过该值知道应该继续执行哪一行的指令。</strong></p><p>​ 一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>​ <strong>无论通过哪种方式退出，在方法退出后都会返回到该方法被调用的位置。</strong></p><p>方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</p><p>而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>1、执行引擎遇到任意一个方法返回的字节码指令(return)，会有返回值传递给上层的方法调用者，简称正常完成出口。</p><ul><li><p>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p></li><li><p>在字节码指令中，返回指令包含 ireturn(当返回值是 boolean，byte，char，short 和 int 类型时使用)，</p></li></ul><p>​   lreturn(Long 类型)，freturn(Float 类型)，dreturn(Double 类型)，areturn(引用类型)，</p><p>​   还有一个单独的 return 指令(声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用)。</p><p>2、在方法执行过程中遇到异常(Exception)，并且这个异常没有在方法内进行处理， 也就是只要在本方法的异常表中</p><p>   没有搜索到匹配的异常处理器，就会导致方法退出， 简称异常完成出口。</p><p><strong>通过异常完成出口的方法不会给它的上层调用者产生任何的返回值。</strong></p><p><strong>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</strong></p><table><thead><tr><th style="text-align:center;">运行时数据区</th><th style="text-align:center;">是否会溢出</th><th style="text-align:center;">是否存在 GC</th></tr></thead><tbody><tr><td style="text-align:center;">程序计数器</td><td style="text-align:center;">否</td><td style="text-align:center;">否</td></tr><tr><td style="text-align:center;">虚拟机栈</td><td style="text-align:center;">是</td><td style="text-align:center;">否</td></tr><tr><td style="text-align:center;">本地方法栈</td><td style="text-align:center;">是</td><td style="text-align:center;">否</td></tr><tr><td style="text-align:center;">方法区</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">堆</td><td style="text-align:center;">是</td><td style="text-align:center;">是</td></tr></tbody></table><p><strong>栈可能会出现的两种错误：</strong></p><ul><li><p>StackOverFlowError：若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的</p><p>最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p></li><li><p>OutOfMemoryError：如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，</p><p>则抛出<code>OutOfMemoryError</code>异常</p></li></ul><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><h3 id="概述-2" tabindex="-1"><a class="header-anchor" href="#概述-2" aria-hidden="true">#</a> 概述</h3><ul><li><p>对一个JVM进程来说，堆是唯一的。一个进程包含多个线程，它们是共享同一个堆空间的。</p></li><li><p><strong>堆在JVM启动的时候即被创建，其空间大小也就确定了。但堆内存的大小可以调节。</strong></p></li><li><p>《java虚拟机规范》规定，<strong>堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。</strong></p></li><li><p>所有的线程共享java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer,TLAB)。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p></li></ul><p>​ <img src="'+x+'" alt="image-20230426101959784" loading="lazy"></p><h3 id="堆的内存划分" tabindex="-1"><a class="header-anchor" href="#堆的内存划分" aria-hidden="true">#</a> 堆的内存划分</h3><p>JDK7：</p><p>​ <img src="'+J+'" alt="image-20230426102005803" loading="lazy"></p><p>JDK8：</p><p>​ <img src="'+M+'" alt="image-20230426102013256" loading="lazy"></p><h4 id="堆空间大小设置" tabindex="-1"><a class="header-anchor" href="#堆空间大小设置" aria-hidden="true">#</a> <strong>堆空间大小设置</strong></h4><p><strong>Java 堆区用于存储对象实例</strong>，堆的大小在 JVM 启动时就已经设定好了。可以通过选项&quot;-Xms&quot;和&quot;-Xmx&quot;来进行设置。</p><ul><li><p>&quot;-Xms&quot; 用于表示堆区的起始内存，等价于-xx:InitialHeapSize</p></li><li><p>&quot;-Xmx&quot; 则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p></li></ul><p><strong>一旦堆区中的内存大小超过 &quot;-Xmx&quot; 所指定的最大内存时，将会抛出OutOfMemoryError 异常。</strong></p><p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是<strong>为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下：</p><ul><li><p>初始内存大小：物理电脑内存大小/64</p></li><li><p>最大内存大小：物理电脑内存大小/4</p></li></ul><h4 id="查看堆的使用情况" tabindex="-1"><a class="header-anchor" href="#查看堆的使用情况" aria-hidden="true">#</a> <strong>查看堆的使用情况</strong></h4><ol><li><p>在cmd中，使用 jps 查看当前正运行的进程，然后使用 <code>jstat -gc 进程id</code> 查看该进程的堆内存使用情况</p></li><li><p>使用 -XX:+PrintGCDetails 参数，打印堆内存使用情况</p></li></ol><h4 id="年轻代与老年代" tabindex="-1"><a class="header-anchor" href="#年轻代与老年代" aria-hidden="true">#</a> <strong>年轻代与老年代</strong></h4><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li><p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。生命周期短的，及时回收即可。</p></li><li><p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致。</p></li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(oldGen)</p><p>  其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间(有时也叫做 from 区、to 区)。</p><p>​ <img src="'+_+'" alt="image-20230426102023685" loading="lazy"></p><p>修改年轻代中各区域占比：</p><ul><li><p>Eden：From：To = 8:1:1</p></li><li><p>新生代：老年代 = 1 : 2</p></li></ul><p>配置年轻代与老年代在堆结构的占比：</p><ul><li><p>默认-XX:NewRatio=2，表示年轻代占 1，老年代占 2，年轻代占整个堆的 1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示年轻代占 1，老年代占 4，年轻代占整个堆的1/5</p></li></ul><h4 id="对象分配过程" tabindex="-1"><a class="header-anchor" href="#对象分配过程" aria-hidden="true">#</a> <strong>对象分配过程</strong></h4><ul><li><p>new出来的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园的空间填满，而程序又需要创建新的对象时，JVM 的垃圾回收器将对伊甸园区进行垃圾回收(MinorGC)，</p><p>将伊甸园区中不再被其他对象所引用的对象进行销毁，将剩余对象移动到幸存者0区，然后再加载新的对象到伊甸园区</p></li></ul><p>​ <img src="'+C+'" alt="image-20230426102042447" loading="lazy"></p><ul><li>当伊甸园再次被填满时，会对伊甸园区和幸存者0区进行垃圾回收，此时幸存下来的对象会被放到幸存者 1 区。</li></ul><p>​ <img src="'+y+'" alt="image-20230426102050253" loading="lazy"></p><ul><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</p></li><li><p>在回收时会给每个对象设置一个年龄计数器，经过一次回收后就会加1。当达到设置的次数时，</p><p>将会触发一次Promotion晋升的操作，也就是将对象放入老年区。该次数默认是 15 次。</p><p>通过参数：-Xx:MaxTenuringThreshold= N 进行设置。</p></li></ul><p>​ <img src="'+G+'" alt="image-20230426102059056" loading="lazy"></p><ul><li><p>在老年区，相对悠闲。当老年区内存不足时，再次触发 Major GC，进行老年区的内存清理。</p></li><li><p><strong>若老年区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生OOM 异常。</strong></p></li></ul><p>​   注意：在 Eden 区满了的时候，才会触发 MinorGC，而幸存者区满了后，不会触发 Minor GC 操作。</p><p>  <strong>如果 Survivor 区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。</strong></p><p>  MinorGC使用的是复制算法。</p><p>  MajorGC采用标记-清除算法，会产生内存碎片。</p><p>总结：</p><ul><li><p>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</p></li><li><p>关于垃圾回收：频繁在新生代区回收，很少在老年代回收。</p></li><li><p><strong>新生代采用复制算法的目的：是为了减少内存碎片</strong></p></li></ul><h4 id="minor-gc、major-gc和full-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc、major-gc和full-gc" aria-hidden="true">#</a> Minor GC、Major GC和Full GC</h4><p>在 Hotspot VM中，它里面的 GC 按照回收区域分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(FullGC)</p><p>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p><p>​ • 新生代收集(MinorGC/YoungGC)：只是新生代的垃圾收集</p><p>​ • 老年代收集(MajorGC/OldGC)：只是老年代的圾收集。</p><p>​ – 目前，只有 CMS GC 会有单独收集老年代的行为。</p><p>​ – 很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p><p>​ • 混合收集(MixedGC)：收集整个新生代以及部分老年代的垃圾收集。</p><p>​ – 目前，只有 G1 GC 会有这种行为。</p><p>​ 整堆收集(Full GC)：收集整个 java 堆和方法区的垃圾。</p><p>​ <strong>如果元空间使用量一旦达到或者超过-XX:MetaspaceSize设置的初始值，就会进行扩容，扩容时会引起Full GC。</strong></p><h4 id="内存分配策略" tabindex="-1"><a class="header-anchor" href="#内存分配策略" aria-hidden="true">#</a> 内存分配策略</h4><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年</p><p>​ 龄设为 1。对象在 Survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度(默认为15 岁，每个 JVM、</p><p>​ 每个 GC 都有所不同)时，就会被晋升到老年代。</p><p>针对不同年龄段的对象分配原则如下所示：</p><p>​ • 优先分配到 Eden</p><p>​ – 开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被</p><p>​ 回收，但是因为老年代触发 Major GC 的次数比Minor GC 要更少，因此可能回收起来就会比较慢。</p><p>​ • 大对象直接分配到老年代</p><p>​ 应尽量避免程序中出现过多的大对象</p><p>​ • 长期存活的对象分配到老年代</p><p>​ • 动态对象年龄判断</p><p>​ <strong>如果survivor区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代</strong></p><p>​ 无须等到 MaxTenuringThreshold 中要求的年龄。</p><p>​ 空间分配担保： -Xx:HandlePromotionFailure</p><h4 id="对象分配规则" tabindex="-1"><a class="header-anchor" href="#对象分配规则" aria-hidden="true">#</a> 对象分配规则</h4><ol><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p></li><li><p>大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在Eden区和两个Survivor区之间发生大量</p><p>​ 的内存拷贝(新生代采用复制算法收集内存)。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，</p><p>之后每经过一次Minor GC那么对象的年龄加1，直到达到阈值对象就会进入老年区。</p></li><li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可</p><p>以直接进入老年代。</p></li><li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余大小则</p><p>​ 进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果是true则只进行Monitor GC，如果是false则进行Full GC。</p></li></ol><h4 id="tlab-thread-local-allocation-buffer" tabindex="-1"><a class="header-anchor" href="#tlab-thread-local-allocation-buffer" aria-hidden="true">#</a> TLAB(Thread Local Allocation Buffer)</h4><p>由来：堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。</p><p>​ <strong>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</strong>。</p><p>​ <strong>为避免多个线程操作同一地址，需要使用加锁等机制，进而又影响分配速度。</strong></p><p>定义：对 Eden 区域继续进行划分，<strong>JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。</strong></p><p>​ 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种</p><p>​ 内存分配方式称之为快速分配策略。</p><p>​ <img src="'+X+'" alt="image-20230426102146599" loading="lazy"></p><p>​ 在程序中，可以通过选项“-Xx:UseTLAB”设置是否开启 TLAB 空间。</p><p>​ 默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，</p><p>​ 可以通过选项“Xx:TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>​ <strong>一旦对象在 TLAB 空间分配内存失败，JVM 就会尝试使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</strong></p><h3 id="堆空间参数设置" tabindex="-1"><a class="header-anchor" href="#堆空间参数设置" aria-hidden="true">#</a> 堆空间参数设置</h3><p>​ • -XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p><p>​ • -XX：+PrintFlagsFinal：查看所有的参数的最终值(可能会存在修改，不再是初始值)</p><p>​ • -Xms：初始堆空间内存(默认为物理内存的 1/64)</p><p>​ • -Xmx：最大堆空间内存(默认为物理内存的 1/4)</p><p>​ • -Xmn：设置新生代的大小。(初始值及最大值)</p><p>​ • -XX:NewRatio：配置新生代与老年代在堆结构的占比</p><p>​ • -XX:SurvivorRatio：设置新生代中 Eden 和 S0/S1 空间的比例</p><p>​ • -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p><p>​ • -XX：+PrintGCDetails：输出详细的 GC 处理日志</p><p>​ – 打印 gc 简要信息：①-Xx：+PrintGC ② - verbose:gc</p><p>​ • -XX:HandlePromotionFalilure：是否设置空间分配担保</p><p>​ 在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><p>​ • 如果大于，则此次 Minor GC 是安全的</p><p>​ • 如果小于，则虚拟机会查看-xx:HandlePromotionFailure 设置值是否允担保失败。</p><p>​ – 如果 HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</p><p>​ – 如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；</p><p>​ – 如果小于，则改为进行一次 Full GC。</p><p>​ – 如果 HandlePromotionFailure=false，则改为进行一次 Full GC。</p><h3 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h3><p>• 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p><p>• 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如，作为调用参数传递到其他地方中。</p><p><strong>判断：就看new出来的对象是否在方法外被调用。</strong></p><p>如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，</p><p>​ 也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p><strong>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除了。</strong></p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>​ • 栈上分配</p><p>​ 将堆分配转化为栈分配。</p><p>​ JIT 编译器在编译期间根据逃逸分析的结果，发现<strong>如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。</strong></p><p>​ 分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。<strong>这样就无须进行垃圾回收了。</strong></p><p>​ • 同步省略</p><p>​ 如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>​ 在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到</p><p>​ 其他线程。如果没有，那么 JIT编译器<strong>在编译这个同步块的时候就会取消对这部分代码的同步</strong>。这样就能提高并发性和性能。</p><p>​ 这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>​ • 分离对象或标量替换</p><p>​ 标量(scalar)是指一个无法再分解成更小的数据的数据。</p><p>​ Java 中的原始数据类型就是标量。</p><p>​ 相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java 中的对象就是聚合量，因为它可以分解成其他聚合量和标量。</p><p>​ 在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，就可以<strong>把这个对象拆解成若干个其中包含的成员变量来代替</strong></p><p>​ 这个过程就是标量替换。</p><p>​ <strong>标量替换为栈上分配提供了基础。</strong></p><p>​ 相关参数：</p><p>​ • 参数-server：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</p><p>​ • 参数-XX:+DoEscapeAnalysis：启用逃逸分析</p><p>​ • 参数-Xmx10m：指定了堆空间最大为 10MB</p><p>​ • 参数-XX:+PrintGC：将打印 Gc 日志</p><p>​ • 参数一 xx：+EliminateAllocations：开启了标量替换(默认打开)，允许将对象打散分配在栈上，比如对象拥有 id 和 name</p><p>​ 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。</p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h2><h3 id="栈-堆-方法区的交互关系" tabindex="-1"><a class="header-anchor" href="#栈-堆-方法区的交互关系" aria-hidden="true">#</a> 栈，堆，方法区的交互关系</h3><p>​ <img src="'+k+'" alt="image-20230426102204688" loading="lazy"></p><p>​ Person：Person类的类信息 放在元空间，即方法区中</p><p>​ person：放在栈的局部变量表中，是一个指向堆中对象的指针</p><p>​ new Person()：放在Java堆中</p><h3 id="概述-3" tabindex="-1"><a class="header-anchor" href="#概述-3" aria-hidden="true">#</a> 概述</h3><p>​ • 方法区可看作是一块独立于 Java 堆且是各个线程共享的内存区域。</p><p>​ • 方法区主要存放的是Class信息，而堆中主要存放的是实例化的对象。</p><p>​ • 方法区在 JVM 启动的时候被创建，在JVM关闭时释放，并且<strong>它的实际物理内存空间和 堆一样都可以是不连续的。</strong></p><p>​ • 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p><p>​ • <strong>方法区的大小决定了系统可以保存多少个类</strong>，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：</p><p>​ java.lang.OutofMemoryError： PermGen space 或者 java.lang.OutOfMemoryError:Metaspace</p><p>​ 原因： 加载大量的第三方的 jar 包</p><p>​ Tomcat 部署的工程过多(30~50 个)</p><p>​ 大量动态的生成反射类</p><p>​ 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。</p><p>​ <strong>元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p><p>​</p><h3 id="方法区内部结构" tabindex="-1"><a class="header-anchor" href="#方法区内部结构" aria-hidden="true">#</a> 方法区内部结构</h3><p><strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</strong></p><h4 id="类型信息" tabindex="-1"><a class="header-anchor" href="#类型信息" aria-hidden="true">#</a> 类型信息</h4><p>对每个加载的类型(类 class、接口 interface、枚举 enum、注解 annotation)，JVM必须在方法区中存储以下信息：</p><p>​ • 这个类型的完整有效名称(全名=包名.类名)</p><p>​ • 这个类型直接父类的完整有效名(对于 interface 或是 java.lang.object，都没有父类)</p><p>​ • 这个类型的修饰符(public，abstract，final 的某个子集)</p><p>​ • 这个类型实现的接口的一个有序列表(即，都实现了哪些接口)</p><h4 id="域信息-成员变量" tabindex="-1"><a class="header-anchor" href="#域信息-成员变量" aria-hidden="true">#</a> 域信息(成员变量)</h4><p>​ JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>​ 域的相关信息包括：域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient 的某个子集)</p><h4 id="方法-method-信息" tabindex="-1"><a class="header-anchor" href="#方法-method-信息" aria-hidden="true">#</a> 方法(Method)信息</h4><p>​ JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><p>​ • 方法名称</p><p>​ • 方法的返回类型(或 void)</p><p>​ • 方法参数的数量和类型(按顺序)</p><p>​ • 方法的修饰符(public，private，protected，static，final，synchronized，native，abstract 的一个子集)</p><p>​ • 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract 和 native 方法除外)</p><p>​ • 异常表(abstract 和 native 方法除外)</p><p>​ 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p><h4 id="non-final-的类变量" tabindex="-1"><a class="header-anchor" href="#non-final-的类变量" aria-hidden="true">#</a> non-final 的类变量</h4><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。</p><p>类变量被类的所有实例共享，即使没有类实例也可以访问它。</p><h3 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池" aria-hidden="true">#</a> 常量池</h3><p>​ 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含常量池表。</p><p>​ <strong>常量池表(Constant Pool Table)：包括各种字面量和对类型、域和方法的符号引用，即数量值、字符串值、类引用、字段引用、</strong></p><p>​ <strong>方法引用。</strong></p><p>​ <strong>虚拟机指令根据常量池表找到要执行的类名、方法名、参数类型、字面量等类型。</strong></p><h3 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池" aria-hidden="true">#</a> 运行时常量池</h3><p>• 运行时常量池(Runtime Constant Pool)是方法区的一部分。</p><p>• 常量池表(Constant Pool Table)是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载</p><p>​ 后(Java 虚拟机对 class 文件采用的是按需加载的方式)存放到方法区的运行时常量池中。</p><p>• 运行时常量池，<strong>在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</strong></p><p>• <strong>JVM 为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</strong></p><p>• 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用，</p><p>​ 此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>• 运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。</p><p>• 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛</p><p>​ outofMemoryError异常。</p><p><strong>关系</strong></p><p>运行时常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，</p><p>用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>Java 虚拟机对 Class 文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，</p><p>​ 这样才会被虚拟机认可、装载和执行。</p><h3 id="方法区的演变" tabindex="-1"><a class="header-anchor" href="#方法区的演变" aria-hidden="true">#</a> 方法区的演变</h3><figure><img src="'+V+'" alt="image-20230426102235087" tabindex="0" loading="lazy"><figcaption>image-20230426102235087</figcaption></figure><p>​ <img src="'+S+'" alt="image-20230426102255172" loading="lazy"></p><h3 id="方法区的垃圾回收" tabindex="-1"><a class="header-anchor" href="#方法区的垃圾回收" aria-hidden="true">#</a> 方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型。</strong></p><p>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。</p><p>​ 字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。</p><p>​ 而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><p>​ • 类和接口的全限定名</p><p>​ • 字段的名称和描述符</p><p>​ • 方法的名称和描述符</p><p>HotSpot 虚拟机对常量池的回收策略：<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong></p><p>​ 回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>​ 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。</p><p>​ 需要同时满足下面三个条件：</p><p>​ • 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</p><p>​ • 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 osGi、JSP 的重加载等，</p><p>​ 否则通常是很难达成的。</p><p>​ • 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>​ Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><p>​ 关于是否要对类型进行回收，HotSpot 虚拟机提供了-Xnoclassgc 参数进行控制，还可以使用</p><p>​ -verbose:class 以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading 查看类加载和卸载信息。</p><p>​ • 在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 oSGi 这类频繁自定义类加载器的场景中，通常都需要</p><p>​ Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><h3 id="本地方法-native-method" tabindex="-1"><a class="header-anchor" href="#本地方法-native-method" aria-hidden="true">#</a> 本地方法(Native Method)</h3><p>该方法是用非Java语言实现的，比如C。</p><p>​ 一个Native Method就是一个Java调用非Java代码的接口。</p><p>​ 在定义一个 native method 时，并不提供实现体(就像定义一个 Java interface)， 因为其实现体是由非 java 语言在外面实现的。</p><p>​ 本地方法接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><p>​ <strong>本地方法在java中使用native关键字，该关键字可以与其他java标识符连用，但abstract除外。</strong></p><p>​ 使用原因：</p><p>​ Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><p>​ 与Java 环境的交互：</p><p>​ 有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。</p><p>​ Java 需要与一些底层系统，如操作系统或某些硬件交换信息。</p><p>​ 本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</p><p>​ 与操作系统的交互：</p><p>​ JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码</p><p>​ 的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。</p><p>​ 这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用 Java 实现了 jre与底层系统的交互， 甚至JVM的一些部分</p><p>​ 就是用 c 写的。</p><p>​ 还有，<strong>如果要使用一些 Java 语言本身没有提供封装的操作系统的特性时，也需要使用本地方法。</strong></p><h3 id="本地方法栈-1" tabindex="-1"><a class="header-anchor" href="#本地方法栈-1" aria-hidden="true">#</a> 本地方法栈</h3><p>Java 虚拟机栈用于管理 Java 方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p><strong>本地方法栈，也是线程私有的。</strong></p><p>本地方法栈允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p><p>​ • 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 stackoverflowError 异常。</p><p>​ • 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存， 或者在创建新的线程时没有足够的内存去创建对应</p><p>​ 的本地方法栈，那么 Java虚拟机将会抛出一个 outofMemoryError 异常。</p><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 <strong>Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</strong></p><p>​ <img src="'+j+'" alt="image-20230426102311679" loading="lazy"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><p>​ • 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</p><p>​ • 它甚至可以直接使用本地处理器中的寄存器</p><p>​ • 直接从本地内存的堆中分配任意数量的内存。</p><p>​ 并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</p><p>​ 如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>',420);function P(T,F){return p(),r("div",null,[n(" permalink: /JVM/ "),z])}const w=a(E,[["render",P],["__file","运行时内存空间.html.vue"]]);export{w as default};
