import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as p,f as e,a as t}from"./app-a89b456a.js";const o="/assets/image-20230721194633245-64be3b4d.png",r="/assets/image-20230721194758511-01bea7b3.png",n="/assets/image-20230721203018849-6ff7d8e5.png",i="/assets/image-20230721195000290-a80fbb15.png",c="/assets/image-20230721195137152-e93e3e00.png",g="/assets/image-20230721195340368-54506190.png",d="/assets/image-20230721195637209-126f421f.png",l="/assets/image-20230721195702823-cb9c05f6.png",m="/assets/image-20230721195730943-52e463a7.png",h="/assets/删除堆顶元素4-90633757-90633757.png",_="/assets/删除堆顶元素5-ca1fc0c4-ca1fc0c4.png",f="/assets/删除堆顶元素6-9549fe90-9549fe90.png",b="/assets/建堆1-87738933-87738933.png",u="/assets/建堆2-f6cd7436-f6cd7436.png",y="/assets/建堆3-476a908d-476a908d.png",z="/assets/建堆4-c306ac75-c306ac75.png",x="/assets/堆排序1-4a22573f-4a22573f.png",O="/assets/堆排序2-26994f33-26994f33.png",k="/assets/堆排序3-e411601b-e411601b.png",V="/assets/堆排序4-2b2472be-2b2472be.png",q="/assets/image-20230721203619943-c4b19345.png",v="/assets/image-20230721203639485-b371e7ac.png",B={},N=t('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><ol><li><p>完全二叉树：若二叉树的深度为h，除第h层外，其他层的结点全部达到最大值，且第h层的所有结点都集中在左子树。</p></li><li><p>满二叉树：满二叉树是一种特殊的的完全二叉树，所有层的结点都是最大值。</p></li></ol><p><strong>堆是一种满足以下条件的树：堆中的每一个父节点的值都大于等于(或小于等于)子树上所有节点的值。</strong></p><p>注意：</p><p>  <strong>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。</strong></p><p>  例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。</p><p>    唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p><h2 id="堆与二叉搜索树的区别" tabindex="-1"><a class="header-anchor" href="#堆与二叉搜索树的区别" aria-hidden="true">#</a> 堆与二叉搜索树的区别</h2><h4 id="节点的顺序" tabindex="-1"><a class="header-anchor" href="#节点的顺序" aria-hidden="true">#</a> <strong>节点的顺序：</strong></h4><p>在二叉搜索树中，左子节点必须比父节点小，右子节点必须比父节点大。但是在堆中并非如此，</p><p>在大根堆中左右子节点值都必须比父节点小，而在小根堆中，左右子节点的值都必须比父节点大。</p><h4 id="内存占用" tabindex="-1"><a class="header-anchor" href="#内存占用" aria-hidden="true">#</a> <strong>内存占用：</strong></h4><p>普通树占用的内存空间比它们存储的数据要多，因为必须为节点对象以及左/右子节点指针分配内存。</p><p><strong>堆仅仅使用一个数组来存储数据，且不使用指针。</strong></p><h4 id="平衡" tabindex="-1"><a class="header-anchor" href="#平衡" aria-hidden="true">#</a> <strong>平衡：</strong></h4><p>​ 二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(logn)。可以按任意顺序位置插入/删除数据，</p><p>​ 或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。只需要满足堆属性即可，所以在堆中平衡不是问题。</p><p>​ 因为堆中数据的组织方式可以保证O(logn)的性能。</p><h4 id="搜索" tabindex="-1"><a class="header-anchor" href="#搜索" aria-hidden="true">#</a> <strong>搜索：</strong></h4><p>在二叉树中搜索会很快，但是在堆中搜索会很慢。</p><p>在堆中搜索不是首要目的，因为使用堆的目的是将最大(或最小)的节点放在最前面，从而快速的进行插入、删除操作。</p><h2 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h2><p>当只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p><strong>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。</strong> 因为堆是基于完全二叉树实现的，所以在插入和</p><p>删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 <code>O(log(n))</code>，相比有序数组的 <code>O(n)</code>，效率更高。</p><p><strong>注意：</strong> Heap 初始化的时间复杂度为 <code>O(n)</code>，而非<code>O(nlogn)</code>。</p><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h2><p>堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。</p><ul><li><p><strong>最大堆</strong>：堆中的每一个节点的值都大于等于子树中所有节点的值</p></li><li><p><strong>最小堆</strong>：堆中的每一个节点的值都小于等于子树中所有节点的值</p><p>图 1 是最大堆，图 2 是最小堆</p></li></ul><p>​ <img src="'+o+'" alt="image-20230721194633245" loading="lazy"></p><h2 id="存储" tabindex="-1"><a class="header-anchor" href="#存储" aria-hidden="true">#</a> 存储</h2><p>由于完全二叉树的优秀性质，可以<strong>利用数组存储二叉树</strong>，既节省空间，又方便索引。</p><p>若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>。</p><p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示</p><p>​ <img src="'+r+'" alt="image-20230721194758511" style="zoom:80%;"></p><p><strong>在堆中，在当前层级所有的节点都已经填满之前不允许开始下一层的填充，所以堆总是有这样的形状：</strong></p><p>​ <img src="'+n+'" alt="image-20230721203018849" style="zoom:80%;"></p><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作" aria-hidden="true">#</a> 操作</h2><h3 id="插入元素" tabindex="-1"><a class="header-anchor" href="#插入元素" aria-hidden="true">#</a> 插入元素</h3><p>1.将要插入的元素放到最后</p><p>​ <img src="'+i+'" alt="image-20230721195000290" style="zoom:65%;"></p><p>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</p><p>​ <img src="'+c+'" alt="image-20230721195137152" style="zoom:67%;"></p><p>​ <img src="'+g+'" alt="image-20230721195340368" style="zoom:67%;"></p><h3 id="删除堆顶元素" tabindex="-1"><a class="header-anchor" href="#删除堆顶元素" aria-hidden="true">#</a> 删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。</p><p>当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p><strong>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整</strong>，这个过程称之为&quot;<strong>堆化</strong>&quot;，</p><p>堆化的方法分为两种：</p><ul><li><p>一种是自底向上的堆化，插入元素时所使用的就是自底向上的堆化，元素从最底部向上移动。</p></li><li><p>另一种是自顶向下堆化，元素由最顶部向下移动。</p></li></ul><p><strong>自底向上堆化：</strong></p><p>​ <img src="'+d+'" alt="image-20230721195637209" style="zoom:67%;"></p><p>​ <img src="'+l+'" alt="image-20230721195702823" style="zoom:67%;"></p><p>​ <img src="'+m+'" alt="image-20230721195730943" style="zoom:67%;"></p><p>​ 数组中出现了“气泡”，这会导致存储空间的浪费。</p><p><strong>自顶向下堆化：</strong></p><p>​   自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。</p><p>​   这个石头就是堆的最后一个元素，先将最后一个元素移动到堆顶。</p><p>​ <img src="'+h+'" alt="删除堆顶元素4" style="zoom:67%;"></p><p>然后开始将这个石头沉入海底，不停地与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p><p>​ <img src="'+_+'" alt="删除堆顶元素5" style="zoom:67%;"></p><p>​ <img src="'+f+'" alt="删除堆顶元素6" style="zoom:67%;"></p><h2 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h2><p>堆排序的过程分为两步：</p><ul><li><p>第一步是建堆，先将一个无序的数组建造成一棵完全二叉树，然后进行非叶子结点的堆化。</p></li><li><p>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</p></li></ul><h3 id="建堆" tabindex="-1"><a class="header-anchor" href="#建堆" aria-hidden="true">#</a> 建堆</h3><p><strong>建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</strong></p><p>首先要了解哪些是非叶节点，<strong>最后一个节点的父结点及该父节点之前的元素都是非叶节点</strong>。</p><p>即，如果节点个数为 n，那么需要对索引为 1 到 n/2 的节点进行自顶向下(沉底)堆化。</p><p>具体过程如下图：</p><p>​ <img src="'+b+'" alt="建堆1" style="zoom:67%;"></p><p>​ 将初始的无序数组抽象为一棵树，图中节点个数为 6，所以 4,5,6 节点为叶节点，1,2,3 节点为非叶节点，所以要对 1-3 号</p><p>​ 节点进行自顶向下(沉底)堆化。</p><p>​ 注意：<strong>堆化顺序是从后往前进行自顶向下的堆化，先从 3 号节点开始判断是否需要和子节点交换位置，然后判断2号节点，最后判断 1 号节点</strong>。</p><p>3 号节点堆化结果：</p><p>​ <img src="'+u+'" alt="建堆1" style="zoom:67%;"></p><p>​ <img src="'+y+'" alt="建堆1" style="zoom:67%;"></p><p>​ <img src="'+z+'" alt="建堆1" style="zoom:67%;"></p><h3 id="排序" tabindex="-1"><a class="header-anchor" href="#排序" aria-hidden="true">#</a> 排序</h3><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>我们<strong>需要执行自顶向下堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，</strong></p><p>由于堆中元素已经减少，这个位置不会再被使用，所以可以将取出的元素放在数组末尾。</p><p><strong>这其实是做了一次交换操作，将堆顶元素和末尾元素调换位置。</strong></p><p>​ <img src="'+x+'" alt="堆排序1" style="zoom:67%;"></p><p>​ <img src="'+O+'" alt="堆排序2" style="zoom:67%;"></p><p>​ <img src="'+k+'" alt="堆排序3" style="zoom:67%;"></p><p>​ <img src="'+V+'" alt="堆排序4" style="zoom:67%;"></p><p>​ <img src="'+q+'" alt="image-20230721203619943" style="zoom:67%;"></p><p>​ <img src="'+v+'" alt="image-20230721203639485" style="zoom:67%;"></p>',89);function A(C,E){return a(),p("div",null,[e(" permalink: /面试/数据结构/    "),N])}const S=s(B,[["render",A],["__file","堆.html.vue"]]);export{S as default};
