import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,a as d}from"./app-a89b456a.js";const l="/assets/image-20231103091753140-ed8f8e58.png",r="/assets/151257-20221216160551074-1896245440-54aeff3d.png",a="/assets/151257-20221216160628213-128154041-d0ac5fe7.png",n="/assets/151257-20221216161452975-1997265924-c1832553.png",s="/assets/151257-20221216161612604-957381529-83491c97.png",o="/assets/image-20231012134544169-052f6f36.png",g="/assets/151257-20221216161827394-1602053625-3d99b719.png",c="/assets/151257-20221216161917813-1123805083-fc12089d.png",p={},h=d('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><h4 id="工作区" tabindex="-1"><a class="header-anchor" href="#工作区" aria-hidden="true">#</a> <strong>工作区</strong></h4><p>电脑上写代码的地方，在这里新增文件、修改文件内容，或删除文件</p><h4 id="暂存区-stage-index" tabindex="-1"><a class="header-anchor" href="#暂存区-stage-index" aria-hidden="true">#</a> <strong>暂存区(stage/index)</strong></h4><p>临时存放文件的修改，实际上它只是一个文件(.git/index)，保存待提交的文件列表信息</p><p>用<code>git add</code> 命令可以将工作区的修改保存到暂存区中。</p><h4 id="版本库-仓库-repository" tabindex="-1"><a class="header-anchor" href="#版本库-仓库-repository" aria-hidden="true">#</a> <strong>版本库/仓库(Repository)</strong></h4><p>Git的管理仓库，管理版本的数据库，记录文件/目录状态的地方，所有内容的修改记录(版本)都在这里。</p><p>就是工作区目录下的隐藏文件夹<code>.git</code>，包含暂存区、分支、历史记录等信息。</p><p>用 <code>git commit</code> 命令可以将暂存区的内容正式提交到版本库。</p><p>​ <img src="'+l+'" alt="image-20231103091753140" loading="lazy"></p><h4 id="服务端-远程仓库" tabindex="-1"><a class="header-anchor" href="#服务端-远程仓库" aria-hidden="true">#</a> <strong>服务端/远程仓库</strong></h4><p>服务端的版本库，专用的Git服务器，为多人共享提供服务，承担中心服务器的角色。本地版本库通过push指令把代码推送到服务端版本库。</p><h4 id="分支" tabindex="-1"><a class="header-anchor" href="#分支" aria-hidden="true">#</a> <strong>分支</strong></h4><p>分支是从主线分离出去的“副本”，可以独立操作而互不干扰，仓库初始化就有一个默认主分支<code>master</code>。</p><h4 id="头" tabindex="-1"><a class="header-anchor" href="#头" aria-hidden="true">#</a> <strong>头</strong></h4><p>HEAD类似一个“指针”，指向当前活动 <strong>分支的最新版本</strong>。</p><h4 id="提交-commit" tabindex="-1"><a class="header-anchor" href="#提交-commit" aria-hidden="true">#</a> <strong>提交(Commit)</strong></h4><p>把暂存区的所有变更的内容提交到当前仓库的活动分支。</p><h4 id="推送-push" tabindex="-1"><a class="header-anchor" href="#推送-push" aria-hidden="true">#</a> <strong>推送(Push)</strong></h4><p>将本地仓库的版本推送到服务端(远程)仓库，与他人共享。</p><h4 id="拉取-pull" tabindex="-1"><a class="header-anchor" href="#拉取-pull" aria-hidden="true">#</a> <strong>拉取(Pull)</strong></h4><p>从服务端(远程)仓库获取更新到本地仓库，获取他人共享的更新。</p><h4 id="获取-fetch" tabindex="-1"><a class="header-anchor" href="#获取-fetch" aria-hidden="true">#</a> <strong>获取(Fetch)</strong></h4><p>从服务端(远程)仓库更新，作用同拉取(Pull)，区别是不会自动合并，需要手动合并。</p><h4 id="冲突-conflict" tabindex="-1"><a class="header-anchor" href="#冲突-conflict" aria-hidden="true">#</a> <strong>冲突(Conflict)</strong></h4><p>多人对同一文件的工作副本进行更改，并将这些更改合并到仓库时就会面临冲突，需要人工合并处理</p><h4 id="合并-merge" tabindex="-1"><a class="header-anchor" href="#合并-merge" aria-hidden="true">#</a> <strong>合并(Merge)</strong></h4><p>对有冲突的文件进行合并操作，Git会自动合并变更内容，无法自动处理的冲突内容会提示人工处理。</p><h4 id="标签-tags" tabindex="-1"><a class="header-anchor" href="#标签-tags" aria-hidden="true">#</a> <strong>标签(Tags)</strong></h4><p>标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。</p><h2 id="使用流程" tabindex="-1"><a class="header-anchor" href="#使用流程" aria-hidden="true">#</a> 使用流程</h2><ul><li><p>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</p></li><li><p>1、<strong>写代码</strong>：在工作目录中添加、修改代码。</p></li><li><p>2、<strong>暂存</strong>(git add)：将需要进行版本管理的文件放入暂存区域。</p></li><li><p>3、<strong>提交</strong>(git commit)：将暂存区域的文件提交到Git仓库。</p></li><li><p>4、<strong>推送</strong>(git push)：将本地仓库推送到远程仓库，同步版本库。</p></li><li><p>5、<strong>获取更新</strong>(fetch/pull)：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</p></li></ul><p>​ <img src="'+r+'" alt="image" loading="lazy"></p><h2 id="文件状态" tabindex="-1"><a class="header-anchor" href="#文件状态" aria-hidden="true">#</a> 文件状态</h2><ol><li><p>修改之后还没有被add(添加到暂存区)过的文件处于untracked状态</p></li><li><p>add之后文件处于staged状态，此时等待commite</p></li><li><p>commit之后文件处于unmodified(未修改)，这里之所以是unmodified是因为文件会跟仓库中的文件对比</p></li><li><p>当unmodified的文件被修改则会变为modified状态</p></li><li><p>modified之后的文件add之后将继续变为staged状态</p></li><li><p>unmodifed的文件还有一种可能是已经不再需要了，那么可以remove它不再追踪变为untracked状态</p></li></ol><p>​ <img src="'+a+`" alt="image" loading="lazy"></p><h2 id="gitignore文件" tabindex="-1"><a class="header-anchor" href="#gitignore文件" aria-hidden="true">#</a> .gitignore文件</h2><p>在工作区根目录下创建“<code>.gitignore</code>”文件，文件中配置不需要进行版本管理的文件、文件夹。</p><p>“<code>.gitignore</code>”文件本身是被纳入版本管理的，可以共享。有如下规则：</p><ul><li><p><code>#</code> 符号开头为注释。</p></li><li><p>可以使用Linux通配符。</p><ul><li><p>星号(*)代表任意多个字符，</p></li><li><p>问号(?)代表一个字符，</p></li><li><p>方括号( [abc] )代表可选字符范围，</p></li><li><p>大括号( {string1,string2,...} )代表可选的字符串等。</p></li></ul></li><li><p>感叹号(<code>!</code>)开头：表示例外规则，将不被忽略。</p></li><li><p>路径分隔符(/f) <strong>开头</strong>：，表示要<strong>忽略根目录下的文件f。</strong></p></li><li><p>路径分隔符(f/) <strong>结尾</strong>：，表示要<strong>忽略文件夹f下面的所有文件。</strong></p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#为注释</span>

*.txt <span class="token comment">#忽略所有“.txt”结尾的文件</span>

<span class="token operator">!</span>lib.txt <span class="token comment">#lib.txt除外</span>

/temp <span class="token comment">#仅忽略项目根目录下的temp文件,不包括其它目录下的temp，如不包括“src/temp”</span>

build/ <span class="token comment">#忽略build/目录下的所有文件</span>

doc/*.txt <span class="token comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="git使用" tabindex="-1"><a class="header-anchor" href="#git使用" aria-hidden="true">#</a> git使用</h2><h3 id="创建仓库" tabindex="-1"><a class="header-anchor" href="#创建仓库" aria-hidden="true">#</a> 创建仓库</h3><p>创建本地仓库的方法有两种：</p><ul><li><p>一种是创建全新的仓库：<code>git init</code>，会在当前目录初始化创建仓库。</p></li><li><p>另一种是克隆远程仓库：<code>git clone [url]</code></p></li></ul><h3 id="暂存区" tabindex="-1"><a class="header-anchor" href="#暂存区" aria-hidden="true">#</a> 暂存区</h3><table><thead><tr><th style="text-align:left;"><strong>指令</strong></th><th style="text-align:left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left;">git add [file1] [file2]</td><td style="text-align:left;">添加文件到暂存区，包括修改的文件、新增的文件</td></tr><tr><td style="text-align:left;">git add [dir]</td><td style="text-align:left;">同上，添加目录到暂存区，包括子目录</td></tr><tr><td style="text-align:left;">git add .</td><td style="text-align:left;">同上，添加<strong>所有</strong>修改、新增文件（未跟踪）到暂存区</td></tr><tr><td style="text-align:left;">git rm [file]</td><td style="text-align:left;">删除工作区文件，并且将这次删除放入暂存区</td></tr><tr><td style="text-align:left;">git mv [file-original] [file-renamed]</td><td style="text-align:left;">修改文件名，并且将这次修改放入暂存区</td></tr></tbody></table><h3 id="提交commit" tabindex="-1"><a class="header-anchor" href="#提交commit" aria-hidden="true">#</a> 提交commit</h3><p>git commit 提交是以时间顺序被保存到数据库中的，就如游戏关卡一样，每一次提交(commit)就会产生</p><p>一条记录：id + 描述 + 快照内容。</p><ul><li><p><strong>commit id</strong>：根据修改的文件内容采用摘要算法（SHA1）计算出不重复的40位字符，这么长是因为Git是分布式的，要保证唯一性、完整性，一般本地指令中可以只用前几位（6）。</p></li><li><p><strong>描述</strong>：针对本次提交的描述说明，建议准确填写，就跟代码中的注释一样，很重要。</p></li><li><p><strong>快照</strong>：就是完整的版本文件，以对象树的结构存放在仓库下<code>\\.git\\objects</code>目录里，这也是Git效率高的秘诀之一。</p></li></ul><p>多次提交就形成了一条时间线，每次提交完，会移动当前分支<code>master</code>、<code>HEAD</code>的“指针”位置。</p><p>​ <img src="`+n+'" alt="image" loading="lazy"></p><table><thead><tr><th style="text-align:center;"><strong>指令</strong></th><th style="text-align:center;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center;">git commit -m &#39;说明&#39;</td><td style="text-align:center;">提交变更，<code>-m</code>表示设置提交的描述信息，如果不带该参数则会进入编辑模式</td></tr><tr><td style="text-align:center;">git commit -a</td><td style="text-align:center;">参数<code>-a</code>，表示直接从工作区提交到版本库，略过了<code>git add</code>步骤，不包括新增的文件</td></tr><tr><td style="text-align:center;">git commit [file]</td><td style="text-align:center;">提交暂存区的指定文件到仓库区</td></tr><tr><td style="text-align:center;">git commit --amend -m</td><td style="text-align:center;">使用一次新的<code>commit</code>，替代上一次提交，会修改<code>commit</code>的<code>hash</code>值（id）</td></tr><tr><td style="text-align:center;">git log -n20</td><td style="text-align:center;">查看日志(最近20条)，不带参数<code>-n</code>则显示所有日志</td></tr><tr><td style="text-align:center;">git log -n20 --oneline</td><td style="text-align:center;">参数“<code>--oneline</code>”可以让日志输出更简洁（一行）</td></tr><tr><td style="text-align:center;">git log -n20 --graph</td><td style="text-align:center;">参数“<code>--graph</code>”可视化显示分支关系</td></tr><tr><td style="text-align:center;">git log --follow [file]</td><td style="text-align:center;">显示某个文件的版本历史</td></tr><tr><td style="text-align:center;">git blame [file]</td><td style="text-align:center;">以列表形式显示指定文件的修改记录</td></tr><tr><td style="text-align:center;">git reflog</td><td style="text-align:center;">查看所有可用的历史版本记录（实际是HEAD变更记录），包含被回退的记录（<strong>重要</strong>）</td></tr><tr><td style="text-align:center;">git status</td><td style="text-align:center;">查看工作区的文件状态，如果只是在工作区中修改，还没有添加到暂存区，则提示信息是红色的； 如果已经添加到了暂存区，但没有提交到本地仓库，则提示信息是绿色的。使用参数<code>-s</code>输出简要信息</td></tr></tbody></table><img src="'+s+'" alt="image" style="zoom:90%;"><p>通过<code>git log</code>指令可以查看提交记录日志，可以很方便的查看每次提交修改了哪些文件，改了哪些内容，从而进行恢复等操作。</p><p>​ <img src="'+o+'" alt="image-20231012134544169" style="zoom:60%;"></p><h3 id="git的指针引用" tabindex="-1"><a class="header-anchor" href="#git的指针引用" aria-hidden="true">#</a> git的指针引用</h3><p>Git中最重要的就是提交记录了，其他如<strong>标签</strong>、<strong>分支</strong>、<strong>HEAD</strong> 都是对提交记录的“指针”引用，指向这些提交记录。</p><ul><li><p>提交记录之间也存在“指针”引用，每个提交都会指向其上一个提交。</p></li><li><p><strong>标签</strong>：就是对某一个提交记录的<strong>固定</strong>的&quot;指针&quot;引用，取一个别名更容易记忆一些关键节点。存储在工作区根目录下<code>.git\\refs\\tags</code>。</p></li><li><p><strong>分支</strong>：也是指向某一个提交记录的“指针”引用，“指针”位置可变，如提交、更新、回滚。存储在工作区根目录下<code>.git\\refs\\heads</code>。</p></li><li><p><strong>HEAD</strong>：指向当前活动分支(最新提交)的一个“指针”引用，存储在“<code>.git/HEAD</code>”文件中，存储的内容为“<code>ref: refs/heads/master</code>”。</p></li></ul><p>​ <img src="'+g+'" alt="image" style="zoom:90%;"></p><ul><li><p><code>HEAD</code>始终指向当前活动分支，多个分支只能有一个处于活动状态。</p></li><li><p>标签<code>t1</code>在某一个提交上创建后，就不会变了；而分支、<code>HEAD</code>的位置会改变。</p></li><li><p><strong>Github上创建的仓库默认主分支名字是“<code>main</code>”，本地创建的仓库默认主分支名字为“<code>master</code>”。</strong></p></li></ul><h3 id="唯一标识id" tabindex="-1"><a class="header-anchor" href="#唯一标识id" aria-hidden="true">#</a> 唯一标识id</h3><p>每一次提交都有一个唯一标识，主要就是提交的<code>hash</code>值<code>commit id</code>，在很多指令中会用到，如版本回退、拣选提交等，都需要指定一个commit id。</p><p>使用唯一标识有两种方式：</p><ul><li><p>首先就是<code>commit id</code>，一个40位编码，指令中使用的时候可以只输入前几位（6位）即可。</p></li><li><p>还有一种就是HEAD~n，是基于当前HEAD位置的一个相对坐标。</p><ul><li><p>HEAD   表示当前分支的最新版本，是比较常用的参数。</p></li><li><p>HEAD^   表示上一个版本，HEAD^^  表示上上一个版本。</p></li><li><p>HEAD~ 或 HEAD~1   表示上一个版本，以此类推，HEAD^10  表示最近第10个版本。</p></li><li><p>HEAD@{2} 在 git reflog 日志中标记的提交记录索引。</p></li></ul></li></ul><p>通过<code>git log</code>、<code>git reflog</code>可以查看历史日志，可以看到每次提交的唯一编号（hash）。</p><p>区别是 <strong><code>git reflog</code>可以查看所有操作的记录(实际上是HEAD变更的记录)，包括被撤销回退的提交记录。</strong></p><h3 id="比较命令" tabindex="-1"><a class="header-anchor" href="#比较命令" aria-hidden="true">#</a> 比较命令</h3><p><code>git diff</code> 用来比较不同文件版本之间的差异。</p><table><thead><tr><th style="text-align:left;"><strong>指令</strong></th><th style="text-align:left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>git diff</strong></td><td style="text-align:left;">查看暂存区和工作区的差异</td></tr><tr><td style="text-align:left;">git diff [file]</td><td style="text-align:left;">同上，指定文件</td></tr><tr><td style="text-align:left;">git diff --cached</td><td style="text-align:left;">查看已暂存的改动，就是暂存区与新版本<code>HEAD</code>进行比较</td></tr><tr><td style="text-align:left;">git diff --staged</td><td style="text-align:left;">同上</td></tr><tr><td style="text-align:left;">git diff --cached [file]</td><td style="text-align:left;">同上，指定文件</td></tr><tr><td style="text-align:left;">git diff HEAD</td><td style="text-align:left;">查看已暂存的+未暂存的所有改动，就是与最新版本<code>HEAD</code>进行比较</td></tr><tr><td style="text-align:left;">git diff HEAD~</td><td style="text-align:left;">同上，与上一个版本比较。<code>HEAD~</code>表示上一个版本，<code>HEAD~10</code>为最近第10个版本</td></tr><tr><td style="text-align:left;">git diff [id] [id]</td><td style="text-align:left;">查看两次提交之间的差异</td></tr><tr><td style="text-align:left;">git diff [branch]</td><td style="text-align:left;">查看工作区和分支直接的差异</td></tr></tbody></table><img src="'+c+'" alt="image" style="zoom:90%;"><h3 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h3><table><thead><tr><th style="text-align:left;"><strong>指令</strong></th><th style="text-align:left;"><strong>作用</strong></th></tr></thead><tbody><tr><td style="text-align:left;">git clone [git地址]</td><td style="text-align:left;">从远程仓库克隆到本地（当前目录）</td></tr><tr><td style="text-align:left;">git remote -v</td><td style="text-align:left;">查看所有远程仓库，不带参数<code>-v</code>只显示名称</td></tr><tr><td style="text-align:left;">git remote show [remote]</td><td style="text-align:left;">显示某个远程仓库的信息</td></tr><tr><td style="text-align:left;">git remote add [name] [url]</td><td style="text-align:left;">增加一个新的远程仓库，并命名</td></tr><tr><td style="text-align:left;">git remote rename [old] [new]</td><td style="text-align:left;">修改远程仓库名称</td></tr><tr><td style="text-align:left;">git remote rm [remote-name]</td><td style="text-align:left;">删除远程仓库</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><strong>git pull</strong></td><td style="text-align:left;">拉取与当前分支同名的远程分支(需先关联远程分支) 克隆项目时，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名</td></tr><tr><td style="text-align:left;">git pull [remote] [branch]</td><td style="text-align:left;">拉取远程仓库上的指定分支，并于当前分支合并</td></tr><tr><td style="text-align:left;"><strong>git pull [remote] [branch]:[test]</strong></td><td style="text-align:left;">拉取远程仓库上的指定分支，并与本地的test分支合并</td></tr><tr><td style="text-align:left;">git pull --rebase</td><td style="text-align:left;">使用rebase的模式进行合并</td></tr><tr><td style="text-align:left;">git fetch [remote]</td><td style="text-align:left;">获取远程仓库的所有变动到本地仓库，不会自动合并，需要手动合并</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;"><strong>git push</strong></td><td style="text-align:left;"><strong>推送当前分支到远程仓库的同名分支</strong></td></tr><tr><td style="text-align:left;">git push [remote] [branch]</td><td style="text-align:left;"><strong>推送本地指定分支到远程仓库的同名分支</strong></td></tr><tr><td style="text-align:left;">git push [remote] [test]:[branch]</td><td style="text-align:left;">推送本地test分支到远程仓库的指定分支</td></tr><tr><td style="text-align:left;">git push [remote] --force/-f</td><td style="text-align:left;">强行推送当前分支到远程仓库，即使有冲突。</td></tr><tr><td style="text-align:left;">git push [remote] --all</td><td style="text-align:left;">推送所有分支到远程仓库</td></tr><tr><td style="text-align:left;">git push –u</td><td style="text-align:left;">参数<code>–u</code>表示与远程分支建立关联，第一次执行的时候用，后面就不需要了</td></tr></tbody></table><h3 id="push-pull" tabindex="-1"><a class="header-anchor" href="#push-pull" aria-hidden="true">#</a> push/pull</h3><p><code>git push</code>、<code>git pull</code>是团队协作中最常用的指令，用于同步本地、服务端的更新，与他人协作。</p><p><strong>🔸推送</strong>（push）：推送本地仓库到远程仓库。</p><ul><li>如果推送的更新与服务端存在冲突，则会被拒绝，<code>push</code>失败。一般是有其他人推送了代码，导致文件冲突，可以先<code>pull</code>代码，在本地进行合并，然后再<code>push</code>。</li></ul><p><strong>🔸拉取</strong>（pull）：从服务端仓库更新到本地仓库。</p><ul><li><p><code>git pull</code>：拉取服务端的最新提交到本地，并与本地合并，合并过程同分支的合并。</p></li><li><p><code>git fetch</code>：拉取服务端的最新提交到本地，不会自动合并，也不会更新工作区。</p></li><li><p>git pull = git fetch + git merge</p></li></ul>',81),f=[h];function m(x,u){return e(),i("div",null,f)}const _=t(p,[["render",m],["__file","git简介和使用.html.vue"]]);export{_ as default};
