import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,f as e,a as t}from"./app-a89b456a.js";const p="/assets/image-20230426074622420-84cd19eb.png",o="/assets/image-20230426074630491-cdc9fd67.png",l="/assets/image-20230426074637093-0f65414d.png",r="/assets/image-20230426074647819-cb7c89c3.png",i="/assets/image-20230426074656676-59011f50.png",d="/assets/mysql20210420165311654-1477125b.png",c="/assets/image-20230426074710976-2d4fbc7e.png",u="/assets/image-20230426074721613-3fc223a4.png",k="/assets/image-20230426074736165-5e88d89f.png",g={},h=t('<h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>定义：</p><p>​ <strong>索引(index)是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>​ 优点：</p><p>​   <strong>提高数据检索的效率，降低数据库的IO成本。</strong></p><p>​   通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p>​ 缺点：</p><p>​   索引列也是要<strong>占用空间</strong>的。</p><p>​   索引提高了查询效率，同时却也<strong>降低了更新表的速度</strong>，如对表进行INSERT、UPDATE、DELETE操作时，效率会降低。</p><p>​   创建和维护索引也需要耗费时间。</p><p>​ 大多数情况下，索引查询都是比全表扫描要快的。但如果数据库的数据量不大，使用索引也不一定能够带来很大提升。</p><h2 id="索引结构" tabindex="-1"><a class="header-anchor" href="#索引结构" aria-hidden="true">#</a> 索引结构</h2><p>​ <strong>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构</strong>，主要包含以下几种：</p><p>​ 按照数据结构维度划分：</p><table><thead><tr><th style="text-align:left;">索引结构</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">B+Tree</td><td style="text-align:left;">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td style="text-align:left;">Hash</td><td style="text-align:left;">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持顺序查询和范围查询</td></tr><tr><td style="text-align:left;">R-Tree(空间索引)</td><td style="text-align:left;">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td style="text-align:left;">Full-Text(全文索引)</td><td style="text-align:left;">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><p>​ 不同的存储引擎对于索引结构的支持：</p><table><thead><tr><th style="text-align:left;">索引</th><th style="text-align:left;">InnoDB</th><th style="text-align:left;">MyISAM</th><th style="text-align:left;">Memory</th></tr></thead><tbody><tr><td style="text-align:left;">B+Tree索引</td><td style="text-align:left;">支持</td><td style="text-align:left;">支持</td><td style="text-align:left;">支持</td></tr><tr><td style="text-align:left;">Hash索引</td><td style="text-align:left;">不支持</td><td style="text-align:left;">不支持</td><td style="text-align:left;">支持</td></tr><tr><td style="text-align:left;">R-Tree索引</td><td style="text-align:left;">不支持</td><td style="text-align:left;">支持</td><td style="text-align:left;">不支持</td></tr><tr><td style="text-align:left;">Full-text</td><td style="text-align:left;">5.6版本后支持</td><td style="text-align:left;">支持</td><td style="text-align:left;">不支持</td></tr></tbody></table><h3 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree" aria-hidden="true">#</a> B-Tree</h3><p>B-Tree，B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p><p>以一棵最大度数（max-degree）为5(5阶)的b-tree为例，那么这棵树上每个节点最多存储4个key，会有5个指针：</p><p>​ <img src="'+p+'" alt="image-20230426074622420" loading="lazy"></p><p>特点：</p><p>​   5阶的B树，每一个节点最多存储4个key，对应5个指针。</p><p>​   一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</p><p>​ <strong>在B树中，非叶子节点和叶子节点都会存放数据。</strong></p><h3 id="b-tree-1" tabindex="-1"><a class="header-anchor" href="#b-tree-1" aria-hidden="true">#</a> B+Tree</h3><p>B+Tree是B-Tree的变种，以一棵最大度数（max-degree）为4(4阶)的 B+tree为例，</p><p>​ <img src="'+o+'" alt="image-20230426074630491" loading="lazy"></p><p>​ 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</p><p>​ 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p><h3 id="b-tree-与-b-tree的区别" tabindex="-1"><a class="header-anchor" href="#b-tree-与-b-tree的区别" aria-hidden="true">#</a> B+Tree 与 B-Tree的区别</h3><ul><li><p>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，非叶子节点只存放 key，</p><p>仅起到索引作用。</p></li><li><p>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点，叶子节点形成一个单向链表。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。</p><p>而 B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p></li><li><p>MySQL在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，</p><p>即，将单向链表改为了双向链表，提高了区间访问的性能，可以支持范围查询和顺序扫描。</p></li></ul><p>​ <img src="'+l+'" alt="image-20230426074637093" loading="lazy"></p><h3 id="hash索引" tabindex="-1"><a class="header-anchor" href="#hash索引" aria-hidden="true">#</a> Hash索引</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>​ <img src="'+r+'" alt="image-20230426074647819" loading="lazy"></p><p>​ 如果两个(或多个)键值，映射到一个相同的槽位上，这就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p>​ 哈希冲突：</p><p>​ <img src="'+i+'" alt="image-20230426074656676" loading="lazy"></p><p>​ 特点：</p><p>​   A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，...）</p><p>​   B. 无法利用索引完成排序操作</p><p>​   C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引。</p><h3 id="r-tree-索引" tabindex="-1"><a class="header-anchor" href="#r-tree-索引" aria-hidden="true">#</a> R-Tree 索引</h3><p>一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p><h3 id="全文索引" tabindex="-1"><a class="header-anchor" href="#全文索引" aria-hidden="true">#</a> 全文索引</h3><p>对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。</p><p>一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p><h2 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类" aria-hidden="true">#</a> 索引分类</h2><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h4><table><thead><tr><th style="text-align:left;">分类</th><th style="text-align:left;">含义</th><th style="text-align:left;">特点</th><th style="text-align:left;">关键字</th></tr></thead><tbody><tr><td style="text-align:left;">主键索引    </td><td style="text-align:left;">针对于表中主键创建的索引，不可以有null值</td><td style="text-align:left;">默认自动创建，只能有一个</td><td style="text-align:left;">primary</td></tr><tr><td style="text-align:left;">唯一索引</td><td style="text-align:left;">加速查询，列值唯一，可以有null值</td><td style="text-align:left;">可以有多个</td><td style="text-align:left;">unique</td></tr><tr><td style="text-align:left;">常规索引</td><td style="text-align:left;">快速定位特定数据，仅加速查询，允许数据重复和null值</td><td style="text-align:left;">可以有多个</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">覆盖索引</td><td style="text-align:left;">一个索引包含（或者说覆盖）所有需要查询的字段的值</td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">联合索引</td><td style="text-align:left;">多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</td><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">全文索引</td><td style="text-align:left;">对文本的内容进行分词，进行搜索</td><td style="text-align:left;">可以有多个</td><td style="text-align:left;">fulltext</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th style="text-align:left;">分类</th><th style="text-align:left;">含义</th><th style="text-align:left;">特点</th></tr></thead><tbody><tr><td style="text-align:left;">聚簇索引(Clustered Index)</td><td style="text-align:left;">将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td style="text-align:left;">必须有，而且只有一个</td></tr><tr><td style="text-align:left;">非聚簇索引(Secondary Index)</td><td style="text-align:left;">将数据与索引分开存储</td><td style="text-align:left;">可以存在多个</td></tr></tbody></table><h3 id="聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引" aria-hidden="true">#</a> 聚簇索引</h3><p>又叫聚集索引，<strong>索引结构和数据一起存放的索引，并不是一种单独的索引类型，InnoDB 中的主键索引就属于聚簇索引。</strong></p><p><strong>聚簇索引的优缺点</strong></p><p><strong>优点</strong>：</p><ul><li><p>查询速度非常快 ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一棵多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<strong>相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</strong></p></li><li><p>对排序查找和范围查找优化 ：聚簇索引对于主键的排序查找和范围查找速度非常快。</p></li></ul><p><strong>缺点</strong> ：</p><ul><li><p>依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，如果是类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</p></li><li><p>更新代价大：如果对应索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以<strong>对于主键索引来说，主键一般都是不可被修改的。</strong></p></li></ul><h3 id="非聚簇索引" tabindex="-1"><a class="header-anchor" href="#非聚簇索引" aria-hidden="true">#</a> 非聚簇索引</h3><p><strong>又叫非聚集索引，即索引结构和数据分开存放的索引，并不是一种单独的索引类型。</strong></p><p><strong>二级索引(辅助索引)就属于非聚簇索引。</strong></p><p>MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p>非聚簇索引的叶子节点并不一定存放指向数据的指针，因为二级索引的叶子节点可以存放的是主键，根据主键再回表查数据。</p><p><strong>非聚簇索引的优缺点</strong></p><p><strong>优点</strong> ：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。</p><p><strong>缺点</strong> ：</p><ul><li><p>依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据。</p></li><li><p>可能会二次查询(回表)：这应该是非聚簇索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p></li></ul><p>MySQL 的表的文件截图：</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>聚簇索引和非聚簇索引：</p><p>​ <img src="'+c+'" alt="image-20230426074710976" loading="lazy"></p><p><strong>聚集索引选取规则：</strong></p><ul><li><p>如果存在主键，主键索引就是聚集索引</p></li><li><p>如果不存在主键，将使用第一个唯一(unique)索引作为聚集索引</p></li><li><p>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个6bytes的隐藏字段 row_id 作为自增主键。</p></li></ul><h3 id="回表查询原理" tabindex="-1"><a class="header-anchor" href="#回表查询原理" aria-hidden="true">#</a> 回表查询原理</h3><p>​ <img src="'+u+'" alt="image-20230426074721613" loading="lazy"></p><p>区别：</p><p>​   <strong>聚集索引的叶子节点下挂的是这一行的数据 。</strong></p><p>   <strong>二级索引的叶子节点下挂的是该字段值对应的主键值。</strong></p><p><strong>具体的查找过程：</strong></p><p>​ select * from user where name=&#39;Arm&#39;；</p><p>​ <img src="'+k+`" alt="image-20230426074736165" loading="lazy"></p><p>具体过程如下:</p><p>​ ①由于是根据name字段进行查询，所以先根据name=&#39;Arm&#39;到name字段的二级索引中进行匹配查找。</p><p>​   但是在二级索引中只能查找到 Arm 对应的主键值为10。</p><p>​ ②由于查询返回的结果是要求所有字段，所以还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到</p><p>    主键10对应的行数据。</p><p>​ ③最终拿到这一行的数据，直接返回。</p><p><strong>这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，称之为回表查询。</strong></p><h2 id="索引语法" tabindex="-1"><a class="header-anchor" href="#索引语法" aria-hidden="true">#</a> 索引语法</h2><p>创建索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token punctuation">[</span> <span class="token keyword">unique</span> <span class="token operator">|</span> fulltext <span class="token punctuation">]</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名 <span class="token punctuation">(</span>想要创建索引的字段<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> 表名 <span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名 <span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="sql性能分析" tabindex="-1"><a class="header-anchor" href="#sql性能分析" aria-hidden="true">#</a> SQL性能分析</h2><h3 id="sql执行频率" tabindex="-1"><a class="header-anchor" href="#sql执行频率" aria-hidden="true">#</a> SQL执行频率</h3><p>​ MySQL 客户端连接成功后，通过 show [session|global] status 命令可以查看服务器状态信息。</p><p>​ 通过如下指令，可以查看当前数据库的insert、update、delete、select的访问频次：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session 是查看当前会话 ;</span>

<span class="token comment">-- global 是查询全局数据 ;</span>

<span class="token keyword">show</span> <span class="token keyword">global</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">&#39;Com_______&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。</p><p>​ 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><p>​ <strong>SQL的执行次数可以借助于慢查询日志。</strong></p><h3 id="慢查询日志" tabindex="-1"><a class="header-anchor" href="#慢查询日志" aria-hidden="true">#</a> 慢查询日志</h3><p><strong>慢查询日志记录了执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句。</strong></p><p>MySQL的慢查询日志默认没有开启，可以查看系统变量 slow_query_log：show variables like &#39;slow_query_log&#39;,</p><p>​   显示value值为OFF。</p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息(Linux系统下）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 开启MySQL慢日志查询开关</span>
<span class="token assign-left variable">slow_query_log</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span>
<span class="token assign-left variable">long_query_time</span><span class="token operator">=</span><span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完毕之后，通过systemctl restart mysqld 指令重新启动MySQL服务器，查看慢日志文件中记录的信息：</p><p>​ /var/lib/mysql/localhost-slow.log。</p><h3 id="profile详情" tabindex="-1"><a class="header-anchor" href="#profile详情" aria-hidden="true">#</a> profile详情</h3><p>​ 通过 <code>show profiles;</code> 语句能够在做SQL优化时帮助我们了解时间都耗费在哪里了。</p><p>​ 通过have_profiling参数，能够看到当前MySQL是否开启了profile操作：</p><div class="language-ysql line-numbers-mode" data-ext="ysql"><pre class="language-ysql"><code>select @@have_profiling ; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 可以通过set语句在session/global级别开启profiling：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">set</span> profiling <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 通过以下指令查看SQL语句的耗时：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看每一条SQL的耗时基本情况</span>
<span class="token keyword">show</span> profiles<span class="token punctuation">;</span>

<span class="token comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况   query_id可以通过show profiles;指令查看</span>
<span class="token keyword">show</span> profile <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span>

<span class="token comment">-- 查看指定query_id的SQL语句CPU的使用情况</span>
<span class="token keyword">show</span> profile cpu <span class="token keyword">for</span> query query_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="explain" tabindex="-1"><a class="header-anchor" href="#explain" aria-hidden="true">#</a> explain</h3><p>通过explain或者 desc命令获取 MySQL 执行 select语句的信息，包括 select语句执行过程中表如何连接和表连接的顺序。</p><p>语法：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 直接在select语句之前加上关键字 explain/desc</span>

<span class="token keyword">explain</span> <span class="token keyword">select</span> 字段列表 <span class="token keyword">from</span> 表名 <span class="token keyword">where</span> 条件 <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Explain 执行计划中各个字段的含义:</p><p><strong>id：</strong></p><p>​  <strong>SELECT 标识符，是查询中 SELECT 的序号</strong>，用来标识整个查询中 SELELCT 语句的顺序。</p><p>​  如果 id相同，则从上往下依次执行。如果id不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，</p><p>     则该值可以为 NULL</p><p><strong>select_type：</strong></p><p>​  <strong>表示查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询</strong>，常见的值有：</p><p>​   SIMPLE：简单查询，Union和子查询。</p><p>​   PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</p><p>​   UNION：在 UNION 语句中，UNION 之后出现的 SELECT。</p><p>​   SUBQUERY：子查询中的第一个 SELECT。</p><p>​   DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED。</p><p>​   UNION RESULT：UNION 查询的结果。</p><p><strong>table：</strong></p><p>​  <strong>查询用到的表名</strong>，表名除了正常的表之外，也可能是以下列出的值：</p><p>​  <code>&lt;unionM,N&gt;</code> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</p><p>​  <code>&lt;derivedN&gt;</code> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</p><p>​  <code>&lt;subqueryN&gt;</code> : 本行引用了 id 为 N 的表所产生的子查询结果</p><p><strong>type：</strong></p><p>​  <strong>表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all。</strong></p><p>​  常见的几种类型具体含义如下：</p><p>   NULL：不访问任何表或索引，直接返回结果</p><p>​    system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，</p><p>             则类型是 system ，是 const 的一种特例，<strong>实际中基本不存在这个情况</strong>。</p><p>​    const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件</p><p>​    eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外</p><p>           最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</p><p>    ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行，常出现在关联查询中。</p><p>    index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了</p><p>                  使用到的索引。</p><p>​    range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了，常用于&lt;，&lt;=，&gt;=，between等操作</p><p>​    index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</p><p>​    all：全表扫描，没有优化，最慢的方式</p><p><strong>possible_key：</strong></p><p>​   possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；</p><p>   这种情况下，需要检查 WHERE 语句中所使用到的列，看是否可以通过给这些列添加索引的方法来提高查询性能。</p><p><strong>Key：</strong></p><p>  <strong>实际使用的索引，如果为 NULL，则表示没有使用索引。</strong></p><p><strong>Key_len</strong>：</p><p>  表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，</p><p>     长度越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL。</p><p><strong>ref：</strong></p><p>  当使用索引等值查询时，与索引作比较的列或常量</p><p><strong>rows：</strong></p><p>  <strong>MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。</strong></p><p><strong>filtered：</strong></p><p>  <strong>表示返回结果的行数占需读取行数的百分比</strong>，filtered的值越大越好。</p><p><strong>Extra：</strong></p><p>​ 附加信息，常见的值如下：</p><p>​   Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</p><p>​   Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</p><p>​   Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。</p><p>​   Using index condition：表示查询优化器选择使用了索引条件下推这个特性。</p><p>​   Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p><p>​   Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，</p><p>       MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</p><p>​</p><h2 id="索引使用" tabindex="-1"><a class="header-anchor" href="#索引使用" aria-hidden="true">#</a> 索引使用</h2><h3 id="最左前缀法则" tabindex="-1"><a class="header-anchor" href="#最左前缀法则" aria-hidden="true">#</a> 最左前缀法则</h3><p>如果索引了多列（联合索引），要遵守最左前缀法则。</p><p>最左前缀法则指的是<strong>查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了某一列，索引将会部分失效(后面的字段索引失效)。</strong></p><p>例：</p><p>​ 1.创建联合索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 2.进行查询测试1</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span><span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> 

<span class="token comment">-- 通过以上两组测试，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 3.测试2</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 

<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span> 

<span class="token comment">-- 通过上面的这两组测试，可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 4.测试3</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token operator">and</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 可以看到这个例子也满足最左前缀法则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p><p>  <strong>最左前缀法则中说的最左边的列，是指在查询时，联合索引的最左边的字段(即，第一个字段)必须存在，</strong></p><p>  <strong>与编写SQL语句时，书写的查询条件的先后顺序无关。</strong></p><h3 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询" aria-hidden="true">#</a> 范围查询</h3><p>如果在联合索引中，出现范围查询(&gt;,&lt;)，则范围查询右侧的列索引失效。</p><p>例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 当范围查询使用&gt; 或 &lt; 时，会走联合索引，范围查询右边的status字段是没有走索引的。</span>

<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">&gt;=</span> <span class="token number">30</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 当范围查询使用&gt;= 或 &lt;= 时，会走联合索引，且所有的字段都是走索引的。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;。</p><h3 id="索引失效情况" tabindex="-1"><a class="header-anchor" href="#索引失效情况" aria-hidden="true">#</a> 索引失效情况</h3><h4 id="索引列运算" tabindex="-1"><a class="header-anchor" href="#索引列运算" aria-hidden="true">#</a> <strong>索引列运算</strong></h4><p><strong>不能在索引列上进行运算操作或使用函数，否则索引将失效。</strong></p><p>例：</p><p>​ 1.创建索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> idx_user_phone <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 2.当根据phone字段进行等值匹配查询时, 索引生效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 3.当根据phone字段进行函数运算操作之后，索引失效。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> substring<span class="token punctuation">(</span>phone<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&#39;15&#39;</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="字符串不加引号" tabindex="-1"><a class="header-anchor" href="#字符串不加引号" aria-hidden="true">#</a> <strong>字符串不加引号</strong></h4><p>字符串类型字段使用时，如果不加引号，则索引将失效。</p><p>如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。</p><h4 id="模糊查询" tabindex="-1"><a class="header-anchor" href="#模糊查询" aria-hidden="true">#</a> <strong>模糊查询</strong></h4><p><strong>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</strong></p><p>例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;软件%&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工程&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">like</span> <span class="token string">&#39;%工%&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 在第二个和第三个查询中，索引将会失效。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="or连接条件" tabindex="-1"><a class="header-anchor" href="#or连接条件" aria-hidden="true">#</a> <strong>or连接条件</strong></h4><p>用or连接的查询条件， 如果or前面的条件中的列有索引，而后面的条件中的列没有索引，则涉及的索引都不会被用到。</p><p>即，<strong>当or两侧的条件中的字段都有索引时，索引才会生效。</strong></p><h4 id="数据分布影响" tabindex="-1"><a class="header-anchor" href="#数据分布影响" aria-hidden="true">#</a> <strong>数据分布影响</strong></h4><p><strong>如果MySQL评估使用索引比全表更慢，则不使用索引。</strong></p><p>例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990005&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> phone <span class="token operator">&gt;=</span> <span class="token string">&#39;17799990015&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行第一条语句时没有走索引，执行第二条语句时，使用了索引。</p><p>这是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃使用索引。</p><p>因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描快，此时索引就会失效。</p><h3 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示" aria-hidden="true">#</a> SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是<strong>在SQL语句中加入一些人为的提示来达到优化操作的目的。</strong></p><p>1.use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">use</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 2.ignore index ： 忽略指定的索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">ignore</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 3.force index ： 强制使用索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_user_pro<span class="token punctuation">)</span> <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h3><p><strong>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。</strong></p><p>例：</p><p>​ 1.创建联合索引</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_pro_age_sta <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 2.执行查询语句并分析</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token number">1.</span><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span> profession <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span><span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span>
              
<span class="token number">2.</span><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span>
                
<span class="token number">3.</span><span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>profession<span class="token punctuation">,</span>age<span class="token punctuation">,</span> <span class="token keyword">status</span><span class="token punctuation">,</span> name <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token punctuation">;</span>
               
<span class="token number">4.</span><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_user <span class="token keyword">where</span> profession <span class="token operator">=</span> <span class="token string">&#39;软件工程&#39;</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token keyword">status</span><span class="token operator">=</span> <span class="token string">&#39;0&#39;</span><span class="token punctuation">;</span>          
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析语句执行计划的Extra字段，可以看到前两条语句Using where; Using Index ;</p><p>而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。</p><p>所以当查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据了。</p><p>如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。</p><p>而如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询(除非是根据主键查询，此时只会扫描聚集索引)</p><h3 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h3><p>当字段类型为字符串(varchar，text，longtext等)时，有时候需要索引很长的字符串，这会让索引变得很大，会产生大量的磁盘IO。</p><p>此时可以<strong>只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</strong></p><p>语法：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_xxxx <span class="token keyword">on</span> 表名<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例：</p><p>​ 为tb_user表的email字段，建立长度为5的前缀索引。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">index</span> idx_email_5 <span class="token keyword">on</span> tb_user<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>前缀长度</strong></p><p>  可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，</p><p>  索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> email<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> substring<span class="token punctuation">(</span>email<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tb_user <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="索引使用建议" tabindex="-1"><a class="header-anchor" href="#索引使用建议" aria-hidden="true">#</a> 索引使用建议</h2><h4 id="选择合适的字段创建索引" tabindex="-1"><a class="header-anchor" href="#选择合适的字段创建索引" aria-hidden="true">#</a> <strong>选择合适的字段创建索引</strong></h4><ul><li><p>不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。</p><p>如果字段频繁被查询，又避免不了为 NULL，建议使用 0，1，true，false这样语义较为清晰的短值或短字符作为替代</p></li><li><p>被频繁查询的字段 ：创建索引的字段应该是数据量较大，且查询操作非常频繁的字段。</p></li><li><p>被作为条件查询的字段 ：常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p></li><li><p>频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li><li><p>被经常用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li></ul><h4 id="被频繁更新的字段应该慎重建立索引" tabindex="-1"><a class="header-anchor" href="#被频繁更新的字段应该慎重建立索引" aria-hidden="true">#</a> <strong>被频繁更新的字段应该慎重建立索引</strong></h4><p>  虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。</p><p>  如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h4 id="限制每张表上的索引数量" tabindex="-1"><a class="header-anchor" href="#限制每张表上的索引数量" aria-hidden="true">#</a> <strong>限制每张表上的索引数量</strong></h4><p>  索引并不是越多越好，建议单张表索引不超过 5 个。索引可以提高效率同样可以降低效率。</p><p>  <strong>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</strong></p><p>  因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="尽可能的考虑建立联合索引而不是单列索引" tabindex="-1"><a class="header-anchor" href="#尽可能的考虑建立联合索引而不是单列索引" aria-hidden="true">#</a> <strong>尽可能的考虑建立联合索引而不是单列索引</strong></h4><p>  因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。</p><p>  如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。</p><p>  如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h4 id="注意避免冗余索引" tabindex="-1"><a class="header-anchor" href="#注意避免冗余索引" aria-hidden="true">#</a> <strong>注意避免冗余索引</strong></h4><p>  冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。</p><p>  如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。</p><p>  在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h4 id="字符串类型的字段使用前缀索引代替普通索引" tabindex="-1"><a class="header-anchor" href="#字符串类型的字段使用前缀索引代替普通索引" aria-hidden="true">#</a> <strong>字符串类型的字段使用前缀索引代替普通索引</strong></h4><p>  前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h4 id="避免索引失效" tabindex="-1"><a class="header-anchor" href="#避免索引失效" aria-hidden="true">#</a> <strong>避免索引失效</strong></h4><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li><p>使用 <code>SELECT *</code> 进行查询</p></li><li><p>创建了联合索引，但查询条件未遵守最左前缀法则</p></li><li><p>在索引列上进行计算、函数、类型转换等操作</p></li><li><p>以 <code>%</code> 开头的 like 查询比如 <code>like &#39;%abc&#39;</code></p></li><li><p>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</p></li></ul><p><strong>删除长期未使用的索引</strong></p><p>  删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p><p>  MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p>`,293);function m(y,b){return n(),a("div",null,[e(" permalink: /MySQL/原理/索引    "),h])}const x=s(g,[["render",m],["__file","40.索引.html.vue"]]);export{x as default};
