import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as n,a as i}from"./app-a89b456a.js";const t="/assets/image-20230426075647595-a95926c7.png",a="/assets/image-20230426075656755-5e09f8bd.png",r="/assets/image-20230426075705284-ac70b7f0.png",l="/assets/image-20230426075723237-7a2a67c7.png",p="/assets/image-20230426075732806-62764189.png",o={},m=i('<h2 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h2><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p><strong>哨兵(Sentinel)机制用来实现主从集群的自动故障恢复。</strong></p><p><strong>反客为主的自动版，能够在后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</strong></p><p>​ <img src="'+t+'" alt="image-20230426075647595" loading="lazy"></p><p><strong>作用</strong>：</p><ul><li><p><strong>监控</strong>：Sentinel 会不断检查master和slave是否按预期工作。</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。即使故障实例恢复，也以新的master为主。</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</p></li></ul><h3 id="监控原理" tabindex="-1"><a class="header-anchor" href="#监控原理" aria-hidden="true">#</a> 监控原理</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p></li><li><p>客观下线：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。</p></li></ul><p>​    quorum值最好超过Sentinel实例数量的一半。</p><p>​ <img src="'+a+'" alt="image-20230426075656755" loading="lazy"></p><h3 id="恢复原理" tabindex="-1"><a class="header-anchor" href="#恢复原理" aria-hidden="true">#</a> 恢复原理</h3><p>一旦发现master故障，sentinel需要在salve中选择一个成为新的master，选择依据是这样的：</p><ul><li><p>首先会<strong>判断slave节点与master节点断开时间长短</strong>，如果超过指定值(down-after-milliseconds * 10)则会排除该slave节点</p></li><li><p>然后<strong>判断slave节点的slave-priority值</strong>，越小优先级越高，如果是0，则永不参与选举</p></li><li><p>如果slave-prority一样，则<strong>判断slave节点的offset值</strong>，越大说明数据越新，即，同步的master的数据越多，优先级越高</p></li><li><p>最后是<strong>判断slave节点的运行id大小</strong>，越小优先级越高。</p></li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p><strong>切换流程如下：</strong></p><ul><li><p>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</p></li><li><p>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新master上同步数据。</p></li><li><p>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。</p></li></ul><p>​ <img src="'+r+`" alt="image-20230426075705284" style="zoom:80%;"></p><h3 id="搭建" tabindex="-1"><a class="header-anchor" href="#搭建" aria-hidden="true">#</a> 搭建</h3><p>​ 设置主机的端口号为7001，三个从机的端口号为27001、27002、27003</p><p>​ 1.创建 sentinel.conf 文件(文件名不能更改)</p><p>​   /opt/etc/sentinel.con</p><p>​ 2.配置哨兵</p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="language-ini"><code>port 27001
sentinel announce-ip 192.168.150.101
sentinel monitor mymaster 192.168.150.101 7001 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
dir &quot;/tmp/s1&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ port 27001：  当前sentinel实例的端口</p><p>​ sentinel monitor mymaster ip地址 端口号 1</p><p>​   mymaster：监控对象(主节点)的服务器名称，自定义，任意写</p><p>​   ip地址：监控对象的IP地址</p><p>​   1：至少要有多少个哨兵同意迁移</p><p>​ 3.启动哨兵</p><p>​   redis-sentinel /opt/etc/sentinel.conf</p><p>​ 4.令master节点宕机，查看sentinel日志</p><p>​ <img src="`+l+'" alt="image-20230426075723237" loading="lazy"></p><p><strong>主机挂掉，会根据选举规则在从机中选出新的主机。原主机重启后会变成从机。</strong></p><p>选举的规则：</p><p>​ 1.根据配置文件中设置的优先级别</p><p>​   replica-priority 10 设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</p><p>​ 2.根据偏移量，优先选择偏移量大的。偏移量说明了获得原主机数据的多少。</p><p>​ 3.根据 runid，优先选择最小的。每个redis实例启动后都会随机生成一个40位的runid。</p><p>选举的过程：</p><p>​ <img src="'+p+'" alt="image-20230426075732806" style="zoom:80%;"></p>',42),d=[m];function c(g,u){return s(),n("div",null,d)}const _=e(o,[["render",c],["__file","哨兵模式.html.vue"]]);export{_ as default};
