import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as d,a as o}from"./app-a89b456a.js";const a="/assets/151257-20221216180434023-386526977-3d404d43.png",r="/assets/151257-20221216180604711-1395134601-e0732855.png",s="/assets/151257-20221216163656506-1757464922-09a0d30f.png",l="/assets/151257-20221216180343312-1746404658-42ac11bb.png",i="/assets/151257-20221216180158984-1941427063-4f330564.png",c="/assets/151257-20221216162740918-1802513049-7b551d19.png",n="/assets/151257-20221216162817709-484843872-bdc3a76f.png",g="/assets/image-20231018210207436-7353a228.png",p="/assets/image-20231018210535291-2d8117da.png",h={},m=o('<h2 id="撤销" tabindex="-1"><a class="header-anchor" href="#撤销" aria-hidden="true">#</a> 撤销</h2><h3 id="撤销指令" tabindex="-1"><a class="header-anchor" href="#撤销指令" aria-hidden="true">#</a> 撤销指令</h3><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>git checkout .</td><td>撤销工作区的（未暂存）所有修改，把暂存区的内容(相当于上一个版本)恢复到工作区。</td></tr><tr><td>git checkout --[fileName]</td><td>撤销工作区中某一个文件的修改，回到暂存区中的状态</td></tr><tr><td>git checkout HEAD .</td><td>撤销工作区、暂存区的修改，用<code>HEAD</code>指向的当前分支最新版本替换工作区、暂存区</td></tr><tr><td>git checkout HEAD [file]</td><td>同上，<code>file</code>指定文件</td></tr><tr><td></td><td></td></tr><tr><td>git reset</td><td>撤销暂存区状态，同<code>git reset HEAD</code>，不影响工作区</td></tr><tr><td>git reset HEAD [file]</td><td>同上，指定文件<code>file</code>，<code>HEAD</code>可省略</td></tr><tr><td>git reset [commitId]</td><td>回退到指定版本，清空暂存区，不影响工作区。工作区需要手动<code>git checkout</code>签出</td></tr><tr><td>git reset --soft [commit]</td><td>移动分支<code>master</code>、<code>HEAD</code>到指定的版本，不影响暂存区、工作区，需手动<code>git checkout</code>签出更新</td></tr><tr><td>git reset --hard HEAD</td><td>撤销工作区、暂存区的修改，用当前最新版</td></tr><tr><td>git reset --hard HEAD^</td><td>回退到上一个版本</td></tr><tr><td>git reset --hard HEAD~</td><td>回退到上一个版本，并重置工作区、暂存区内容。</td></tr><tr><td>git reset --hard [commitid]</td><td>回退到某一个指定的版本 每提交一个新版本，Git就会把它们自动串成一条时间线，所以通过指定版本号就可以回退到某一个特定的版本</td></tr></tbody></table><p><strong>撤销有2种情况：</strong></p><ol><li><p>文件修改后，还没有放到暂存区，使用撤销修改就能回到和版本库一模一样的状态。(前提是暂存区的内容已经提交到版本库中)</p></li><li><p>文件的修改已经添加到暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。(上一次的修改还没有提交到版本库中)</p></li></ol><h3 id="回退版本reset" tabindex="-1"><a class="header-anchor" href="#回退版本reset" aria-hidden="true">#</a> 回退版本reset</h3><p><code>reset</code>是专门用来撤销修改、回退版本的指令，支持的场景比较多，参数组合也比较多。简单理解就是<strong>移动<code>master</code>分支 和 <code>HEAD</code>的“指针”地址。</strong></p><p>如下图：</p><ul><li>回退版本<code>git reset --hard v4</code> 或 <code>git reset --hard HEAD~2</code>，<code>master</code>、<code>HEAD</code>会指向<code>v4</code>这个版本的提交，<code>v5</code>、<code>v6</code>版本就被废弃了。</li><li>也可以重新恢复到<code>v6</code>版本：<code>git reset --hard v6</code>，就是移动<code>master</code>、<code>HEAD</code>的“指针”地址</li></ul><p>​ <img src="'+a+'" alt="image" loading="lazy"></p><p><code>reset</code>有三种模式，对应三种参数：<code>mixed</code>(默认模式)、<code>soft</code>、<code>hard</code>。三种参数的主要区别就是对工作区、暂存区的操作不同。</p><ul><li><p><code>mixed</code>为默认模式，参数可以省略。</p></li><li><p>只有<code>hard</code>模式会重置工作区、暂存区，一般用这个模式会多一点。</p></li></ul><p>​ <img src="'+r+'" alt="image" loading="lazy"></p><p><strong>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</strong></p><h3 id="撤销提交revert" tabindex="-1"><a class="header-anchor" href="#撤销提交revert" aria-hidden="true">#</a> 撤销提交revert</h3><p>安全的撤销某一个提交记录，基本原理就是产生一个新的提交，用原提交的逆向操作来完成撤销操作。</p><p>这不同于<code>reset</code>，<code>reset</code>是回退版本，revert只是用于撤销某一次历史提交，操作是比较安全的。</p><p>​ <img src="'+s+'" alt="image" loading="lazy"></p><p>如上图：</p><ul><li><p>想撤销<code>v4</code>的修改，执行<code>git revert v4</code>，会产生一个新的提交<code>v-4</code>，是<code>v4</code>的逆向操作。</p></li><li><p>同时更新<code>maser</code>、<code>HEAD</code>“指针”位置，以及工作区内容。</p></li><li><p>如果已<code>push</code>则重新<code>push</code>即可</p></li></ul><h2 id="标签管理" tabindex="-1"><a class="header-anchor" href="#标签管理" aria-hidden="true">#</a> 标签管理</h2><p><strong>标签</strong>（Tags）指的是某个分支某个特定时间点的状态，<strong>是对某一个提交记录的的固定“指针”引用</strong>。</p><p>​ 一经创建，不可移动，存储在工作区<code>.git\\refs\\tags</code>目录下。可以理解为<strong>是某一次提交(编号)的别名，常用来标记版本</strong>。</p><p>​ 所以发布时，一般都会打一个版本标签，作为该版本的快照，指向对应提交<code>commit</code>。</p><p>​ 当项目达到一个关键节点，希望永远记住那个特别的提交快照，就可以使用 <code>git tag</code>给它打上标签。</p><p>​ 比如今天完成了V1.1版本的开发、测试，并成功上线了，那就可给今天最后这个提交打一个标签“V1.1”，便于版本管理。</p><p>​ 默认标签是打在最新提交的commit上的，如果想要在以前的提交上打标签则带上提交编号(即，commit id)：</p><p>  <code>git tag v0.9 f52c633</code></p><p>​ <img src="'+l+'" alt="image" loading="lazy"></p><table><thead><tr><th style="text-align:left;"><strong>指令</strong></th><th style="text-align:left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left;">git tag</td><td style="text-align:left;">查看标签列表</td></tr><tr><td style="text-align:left;">git tag -l &#39;a*&#39;</td><td style="text-align:left;">查看名称是“a”开头的标签列表，带查询参数</td></tr><tr><td style="text-align:left;">git show [tagname]</td><td style="text-align:left;">查看标签信息</td></tr><tr><td style="text-align:left;"><strong>git tag</strong> [tagname]</td><td style="text-align:left;">创建一个标签，默认标签是打在最新提交的commit上的</td></tr><tr><td style="text-align:left;">git tag [tagname] [commit id]</td><td style="text-align:left;">在指定commit上创建一个tag</td></tr><tr><td style="text-align:left;">git tag -a v5.1 -m &#39;这是v5.1版本&#39;</td><td style="text-align:left;">创建标签<code>v5.1</code>，<code>-a</code>指定标签名，<code>-m</code>指定说明文字</td></tr><tr><td style="text-align:left;">git tag -d [tagname]</td><td style="text-align:left;">删除本地标签</td></tr><tr><td style="text-align:left;">git checkout v5.1.1039</td><td style="text-align:left;">切换标签，同切换分支</td></tr><tr><td style="text-align:left;">git push [remote] [tagname]</td><td style="text-align:left;">推送标签到仓库，因为标签不会默认随代码的推送而推送到服务端</td></tr><tr><td style="text-align:left;">git push [remote] --tags</td><td style="text-align:left;">提交所有tag</td></tr></tbody></table><p><strong>标签总是和某个commit挂钩，如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></p><h2 id="分支" tabindex="-1"><a class="header-anchor" href="#分支" aria-hidden="true">#</a> 分支</h2><h3 id="分支branch" tabindex="-1"><a class="header-anchor" href="#分支branch" aria-hidden="true">#</a> 分支Branch</h3><p>在实际项目中，一般会建几个主线分支。</p><ul><li><p><strong>master</strong>：作为主分支，存放稳定的代码，就是开发后测试通过的代码，不允许随便修改和合并。</p></li><li><p><strong>开发分支</strong>：用于团队日常开发，比如团队计划10月份开发10个功能并发版，则在此分支上进行，不影响主分支的稳定。</p></li><li><p><strong>功能A分支</strong>：开发人员根据自己的需要，可以创建一些临时分支用于特定功能的开发，开发完毕后再合并到开发分支，并删除该分支。</p></li></ul><p><strong>分支</strong>就是指向某一个提交记录的“指针”引用，因此创建分支是非常快的，不管仓库多大。</p><p>当运行<code>git branch dev</code>创建了一个名字为<code>dev</code>的分支时，Git实际上是在<code>.git\\refs\\heads</code>下创建一个<code>dev</code>的引用文件（没有扩展名）</p><table><thead><tr><th style="text-align:left;"><strong>指令</strong></th><th style="text-align:left;"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left;">git branch</td><td style="text-align:left;">列出本地所有分支，星号表示活动分支 参数 <code>-v</code> 显示详细列表，下同</td></tr><tr><td style="text-align:left;">git branch -r</td><td style="text-align:left;">列出远程所有分支</td></tr><tr><td style="text-align:left;">git branch -a</td><td style="text-align:left;">列出本地所有分支和远程所有分支，会用不同颜色区分</td></tr><tr><td style="text-align:left;">git branch [branch-name]</td><td style="text-align:left;">在本地新建一个分支，但依然停留在当前分支</td></tr><tr><td style="text-align:left;">git branch [branch] [commit]</td><td style="text-align:left;">在本地新建一个分支，指向指定的<code>commit id</code></td></tr><tr><td style="text-align:left;">git branch --track [branch] [remote/branch]</td><td style="text-align:left;">在本地新建一个分支，与指定的远程分支建立关联</td></tr><tr><td style="text-align:left;">git branch -d dev</td><td style="text-align:left;">删除<code>dev</code>分支，-D(大写)强制删除</td></tr><tr><td style="text-align:left;">git branch --set-upstream [branch] [remote/branch]</td><td style="text-align:left;">在现有分支与指定的远程分支之间建立跟踪关联</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">git checkout -b dev</td><td style="text-align:left;">新建一个分支，并切换到新创建的分支</td></tr><tr><td style="text-align:left;">git checkout -b dev1 dev</td><td style="text-align:left;">从本地<code>dev</code>分支创建一个 <code>dev1</code>分支，并切换到dev1分支</td></tr><tr><td style="text-align:left;"><strong>git checkout -b dev1 origin/dev</strong></td><td style="text-align:left;">从远程仓库origin 的<code>dev</code>分支创建本地<code>dev1</code>分支，并切换到dev1分支</td></tr><tr><td style="text-align:left;">git checkout [branch-name]</td><td style="text-align:left;">切换到指定分支，并更新工作区</td></tr><tr><td style="text-align:left;">git merge [branch]</td><td style="text-align:left;">合并指定分支到当前分支 参数<code>--no-ff</code>禁用快速合并模式</td></tr><tr><td style="text-align:left;">git push origin --delete [branch-name]</td><td style="text-align:left;">删除远程分支</td></tr><tr><td style="text-align:left;">git rebase master</td><td style="text-align:left;">将当前分支变基合并到<code>master</code>分支</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">✅switch：新的分支切换指令</td><td style="text-align:left;">切换功能和<code>checkout</code>一样，<code>switch</code>只单纯的用于切换</td></tr><tr><td style="text-align:left;">git switch master</td><td style="text-align:left;">切换到已有的<code>master</code>分支</td></tr><tr><td style="text-align:left;">git switch -c dev</td><td style="text-align:left;">创建并切换到新的<code>dev</code>分支</td></tr></tbody></table><h3 id="分支的切换" tabindex="-1"><a class="header-anchor" href="#分支的切换" aria-hidden="true">#</a> 分支的切换</h3><p>代码仓库可以有多个分支，<strong><code>master</code>为默认的主分支，但只有一个分支在工作状态</strong>。</p><p>所以要操作不同分支，需要切换到该分支，<strong><code>HEAD</code>就是指向当前正在活动的分支。</strong></p><p>​ <img src="'+i+'" alt="image" loading="lazy"></p><p>使用 <code>git checkout dev</code>切换分支时，干了两件事：</p><p>​  ①、<code>HEAD</code>指向<code>dev</code>：修改<code>HEAD</code>的“指针”引用，指向<code>dev</code>分支。</p><p>​  ②、还原工作空间：把<code>dev</code>分支内容还原到工作空间。</p><p>此时的活动分支就是<code>dev</code>了，后续的提交都会更新到<code>dev</code>分支。</p><p><strong>切换时还没提交的代码怎么办？</strong></p><ul><li><p>如果修改（包括未暂存、已暂存）和待切换的分支没有冲突，则切换成功，且未提交的修改会一起带过去。</p></li><li><p>如果有冲突，则会报错，提示先提交或隐藏。</p></li></ul><h3 id="合并-冲突" tabindex="-1"><a class="header-anchor" href="#合并-冲突" aria-hidden="true">#</a> 合并&amp;冲突</h3><p>把两个分支的修改内容合并到一起，常用的合并指令<code>git merge [branch]</code>，将分支<code>[branch]</code>合并到当前分支。</p><p>根据要合并的内容的不同，具体合并过程就会有多种情况：</p><p>​ <img src="'+c+'" alt="image" loading="lazy"></p><h4 id="分支无交叉" tabindex="-1"><a class="header-anchor" href="#分支无交叉" aria-hidden="true">#</a> <strong>分支无交叉</strong></h4><p>从main分支创建dev分支，如果<strong>在两个分支中都进行了新增或删除文件的操作，但操作的不是同一个文件</strong>，这种情况就是分支无交叉。</p><p>此时，在main分支中合并dev分支不会出现冲突。</p><p>注意：</p><p>  1.<strong>合并 dev 到 master前，要先切换到master分支</strong></p><p>  2.<strong>两个分支做出修改之后都要进行提交</strong>(如果main分支的修改在没有提交之前就进行合并，则会被强制提交)</p><p>  3.<strong>main分支合并dev分支后文件处于commit状态</strong>，还需要push到远程仓库。</p><p><strong>快速合并(Fast forward)</strong></p><p>如下图，<code>master</code>分支没有任何提交，“<code>git merge dev</code>”合并分支<code>dev</code>到<code>master</code>，此时合并速度就非常快，直接移动</p><p><code>master</code>的“指针”引用到<code>dev</code>即可。这就是快速合并(Fast forward)，不会产生新的提交。</p><p>​ <img src="'+n+`" alt="image" style="zoom:90%;"></p><h4 id="分支有交叉" tabindex="-1"><a class="header-anchor" href="#分支有交叉" aria-hidden="true">#</a> <strong>分支有交叉</strong></h4><p><strong>无文件冲突</strong></p><p>如果main分支和dev分支对同一个文件进行了修改，但修改的内容没有冲突，此时就可以进行合并。</p><p>即，<strong>假设main分支将test.txt文件的一行内容修改为123，dev分支将test文件的同一行的内容修改为12345，此时，</strong></p><p>    <strong>是没有冲突的，如果进行合并，则合并之后的内容为12345。而如果dev分支将内容改为了124，此时合并的话就会</strong></p><p>    <strong>出现冲突。</strong></p><p>​</p><p><strong>有文件冲突(以下实验中，main分支和dev分支在同一个工作区)</strong></p><ol><li><p>从main分支创建dev分支后，如果<strong>两个分支将同一个文件的同一个位置修改为了不同的内容</strong>，此时合并则会出现冲突(此时，分支的状态变成了</p><p>main|MERGING)：</p></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#合并报错：</span>
 Auto-merging dev.txt
 CONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> dev.txt
 Automatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.
 
<span class="token comment">#此时，也可以使用下面的命令回到merge之前</span>
<span class="token function">git</span> reset <span class="token parameter variable">--merge</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>此时，执行<code>git diff</code>命令，就可以看到发生冲突的地方在哪里：</li></ol><p>​ <img src="`+g+'" alt="image-20231018210207436" style="zoom:50%;"></p><p>​ Git用 &lt;&lt;&lt;&lt;&lt;，<code>=======</code>，&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中 &lt;&lt;&lt;HEAD 是指主分支修改的内容，&gt;&gt;&gt;&gt;dev 是指dev上修改的内容。</p><ol start="3"><li>在main分支中查看发生冲突的文件dev.txt(vim dev.txt)：</li></ol><p>​ <img src="'+p+'" alt="image-20231018210535291" style="zoom:67%;"></p><p>​ 此时，人为决定保留哪一部分内容就可以了。</p><ol start="4"><li><p>保存好内容后，执行 <code>git add .</code> 和 <code>git commit -m &#39; &#39;</code> 命令将修改提交，此时分支状态就会变回main。</p></li><li><p>创建dev分支后，如果dev分支做出修改后还没有commit，则此时切换到main分支的话，是能看到dev分支做出的</p><p>修改的，如果dev分支提交了修改，则在main分支中就看不到了。<strong>原因应该是两个分支在同一个工作区，即，使用的是同一个目录。</strong></p></li></ol>',80),f=[m];function v(x,y){return e(),d("div",null,f)}const _=t(h,[["render",v],["__file","撤销和分支.html.vue"]]);export{_ as default};
