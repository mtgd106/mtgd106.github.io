import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as l,f as p,a as s,b as n,d as a}from"./app-a89b456a.js";const i={},c=s(`<h2 id="修饰符" tabindex="-1"><a class="header-anchor" href="#修饰符" aria-hidden="true">#</a> 修饰符</h2><h3 id="访问修饰符" tabindex="-1"><a class="header-anchor" href="#访问修饰符" aria-hidden="true">#</a> 访问修饰符</h3><table><thead><tr><th style="text-align:center;">修饰符</th><th style="text-align:center;">类的使用范围</th></tr></thead><tbody><tr><td style="text-align:center;">private</td><td style="text-align:center;">只能在本类中调用</td></tr><tr><td style="text-align:center;">default</td><td style="text-align:center;">只要是在同一个包中就可以调用</td></tr><tr><td style="text-align:center;">protected</td><td style="text-align:center;">在同一个包中的类可以调用；在其他包中，如果是其子类，也可以调用</td></tr><tr><td style="text-align:center;">public</td><td style="text-align:center;">任何地方都可以调用</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>对外部class的权限修饰只能用public或default</p></li><li><p>public类可以在任意地方被访问，default类只能被同一个包内部的类访问</p></li></ol><h3 id="非访问修饰符" tabindex="-1"><a class="header-anchor" href="#非访问修饰符" aria-hidden="true">#</a> 非访问修饰符</h3><ol><li><p>static</p><p>修饰变量-----静态变量</p><p>  static用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量都只有一份拷贝。</p><p>  <strong>静态变量也被称为类变量；局部变量不能被声明为static变量</strong></p><p>  类变量可以通过类名访问，也可以通过对象名访问。</p><p>修饰方法-----静态方法</p></li></ol><p>    static用来声明独立于对象的静态方法，静态方法可以通过类名访问，也可以通过对象名访问。</p><p>    <strong>静态方法不能使用类的非静态变量</strong>，静态方法从参数列表获得数据</p><ol start="2"><li>finial</li></ol><p>  用来修饰类、方法和变量</p><p>  final 修饰的类不能够被继承</p><p>  final修饰的方法可以被子类继承，但不能被子类重写</p><p>  final修饰的变量为常量，不可修改; <strong>被final修饰的实例变量必须显式指定初始值</strong></p><ol start="3"><li><p>abstract</p><p>修饰类-----抽象类</p><p>  抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充</p><p>  如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误</p><p>  <strong>抽象类可以包含抽象方法和非抽象方法。抽象类也可以不包含抽象方法。</strong></p><p>修饰方法----抽象方法</p><p>  抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p><p>  <strong>抽象方法不能被声明为 final 和 static。</strong></p><p>  任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p></li></ol><h2 id="成员变量和局部变量" tabindex="-1"><a class="header-anchor" href="#成员变量和局部变量" aria-hidden="true">#</a> 成员变量和局部变量</h2><h3 id="成员变量-属性" tabindex="-1"><a class="header-anchor" href="#成员变量-属性" aria-hidden="true">#</a> 成员变量(属性)</h3><ol><li><p>实例变量</p><p>声明在一个类中，但在方法和语句块之外，不以static修饰</p><p>当一个对象被实例化之后，每个实例变量的值就随之确定</p><p><strong>访问修饰符可以用于修饰实例变量</strong></p></li><li><p>类变量(静态变量)</p><p>声明在一个类中，但在方法和语句块之外，以static修饰</p><p>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong></p><p>静态变量存储在静态储存区，初始化后不可改变;在第一次被访问时创建，在程序结束时销毁</p></li></ol><h3 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量" aria-hidden="true">#</a> 局部变量</h3><p>声明在方法或语句块中</p><p><strong>访问修饰符不能用于修饰局部变量</strong></p><table><thead><tr><th style="text-align:center;">区别</th><th style="text-align:center;">成员变量</th><th style="text-align:center;">局部变量</th></tr></thead><tbody><tr><td style="text-align:center;">类中位置不同</td><td style="text-align:center;">类中方法外</td><td style="text-align:center;">方法内或者方法声明上</td></tr><tr><td style="text-align:center;">内存中位置不同</td><td style="text-align:center;">堆内存</td><td style="text-align:center;">栈内存</td></tr><tr><td style="text-align:center;">生命周期不同</td><td style="text-align:center;">随着对象的创建而存在，随着对象的消失而消失</td><td style="text-align:center;">随着方法的调用而存在，随着方法的结束而消失</td></tr><tr><td style="text-align:center;">初始化值不同</td><td style="text-align:center;">有默认的初始化值</td><td style="text-align:center;">没有默认的初始化值，必须先定义赋值，才能使用</td></tr></tbody></table><h2 id="this和super" tabindex="-1"><a class="header-anchor" href="#this和super" aria-hidden="true">#</a> this和super</h2><table><thead><tr><th style="text-align:center;">关键字</th><th style="text-align:center;">访问成员变量</th><th style="text-align:center;">访问构造方法</th><th style="text-align:center;">访问成员方法</th></tr></thead><tbody><tr><td style="text-align:center;">this</td><td style="text-align:center;">this.成员变量</td><td style="text-align:center;">this(...)</td><td style="text-align:center;">this.成员方法(...)</td></tr><tr><td style="text-align:center;">super</td><td style="text-align:center;">super.成员变量</td><td style="text-align:center;">super(...)</td><td style="text-align:center;">super.成员方法(...)</td></tr></tbody></table><p>​</p><h2 id="继承中构造方法的访问特点" tabindex="-1"><a class="header-anchor" href="#继承中构造方法的访问特点" aria-hidden="true">#</a> 继承中构造方法的访问特点</h2><p>子类中所有的构造方法被执行时都会默认访问父类的无参构造方法</p><ol><li><p>因为子类会继承父类中的数据，可能还会使用父类的数据。所以初始化之前，先完成父类数据的初始化。</p></li><li><p>每一个子类构造方法的第一条语句默认都是super( );</p></li></ol><p>如果父类中没有无参构造方法，只有带参构造方法，则</p><ol><li><p>可以通过使用super关键字显式调用父类的某一个带参构造方法</p></li><li><p>当单独定义了带参构造方法时，编译器不再自动定义无参构造方法，可以在父类中自己提供一个无参构造方法</p></li></ol><p>​</p><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><h4 id="_1-多态的形式" tabindex="-1"><a class="header-anchor" href="#_1-多态的形式" aria-hidden="true">#</a> <strong>1.多态的形式</strong></h4><p>​ 具体类多态；抽象类多态；接口类多态</p><h4 id="_2-实现多态的前提" tabindex="-1"><a class="header-anchor" href="#_2-实现多态的前提" aria-hidden="true">#</a> <strong>2.实现多态的前提</strong></h4><ol><li><p>有继承/实现的关系</p></li><li><p>有方法重写</p></li><li><p>有父类/接口类引用指向子类/实现类对象</p></li></ol><p>   例：Animal A=new Cat( );   //Cat类是Animal类的子类</p><h4 id="_3-多态中成员访问特点" tabindex="-1"><a class="header-anchor" href="#_3-多态中成员访问特点" aria-hidden="true">#</a> <strong>3.多态中成员访问特点</strong></h4><ol><li><p>成员变量</p><p>编译看左边，执行看左边 (即，如果Animal类中有该变量，则编译成功，且执行时也是用的Animal中该变量的值)</p></li><li><p>成员方法</p><p>编译看左边，执行看右边 (即，如果Animal类中有该方法，则编译成功；但执行时是看Cat类中该方法的具体实现；</p><p>如果Cat类中没有该方法，则执行父类中的方法)</p><p>例：</p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>     <span class="token comment">//定义一个动物类</span>
                       
  <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
                        
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                   
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;动物吃东西&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>                

<span class="token comment">//定义一个Cat类继承Animal类,且重写了eat方法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    
                               
  <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
                                
  <span class="token keyword">public</span> <span class="token keyword">int</span> weight<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span>
                                                    
  <span class="token annotation punctuation">@Override</span>                                 
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                          
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫吃鱼&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
                                                                
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                                          
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;猫捉迷藏&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>                   
  
<span class="token class-name">Animal</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//父类引用指向子类对象    </span>
  
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出结果为10   </span>
                    
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错  Animal类中没有weight变量</span>
                    
a<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输出:猫吃鱼</span>
                   
a<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//报错，不能执行一个子类中独有而父类中没有的方法 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-多态中的转型" tabindex="-1"><a class="header-anchor" href="#_4-多态中的转型" aria-hidden="true">#</a> <strong>4.多态中的转型</strong></h4><p>多态的好处：提高了程序的扩展性，定义方法时，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作。</p><p>多态的弊端：<strong>实例化的对象不能使用子类的特有功能，而多态的转型可以解决这个问题</strong>。</p><ol><li><p>向上转型</p><p>从子到父，父类引用指向子类对象</p><p>例：Animal a=new Cat();   //此时，a可以调用父类中的所有成员(有权限的前提下)，但不能调用Cat类中的特有成员</p></li><li><p>向下转型</p><p>从父到子，父类引用转为子类对象</p><p>例：Cat c=(Cat)a;   //将a强制转为Cat类，且堆中不会创建新的对象</p></li></ol><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><p>​ <strong>一个没有方法体的方法应该定义为抽象方法，如果类中有抽象方法，则该类必须定义为抽象类。</strong></p><ol><li><p>抽象类中可以只有非抽象方法，如果有抽象方法，一定要定义为抽象类。</p></li><li><p>抽象类不能直接实例化，但可以参照多态的方式，通过父类引用指向子类对象的方式实现实例化。</p></li><li><p>抽象类的子类必须重写父类中的所有抽象方法，除非子类也是个抽象类。</p></li></ol><p>抽象类的成员特点：</p><ol><li><p>成员变量可以是变量，也可以是常量</p></li><li><p>可以有无参和带参构造方法</p></li><li><p>有抽象方法，限定子类必须完成某些动作</p></li></ol><h2 id="接口类" tabindex="-1"><a class="header-anchor" href="#接口类" aria-hidden="true">#</a> 接口类</h2>`,50),o=n("ol",null,[n("li",null,[n("p",null,"子类继承接口类时使用implements关键字"),n("p",null,"public class 类名 implements 接口名")]),n("li",null,[n("p",null,"接口类也需要通过多态的方式进行实例化"),n("p",null,"例：Animal a=new Cat( );   //Animal是接口类，Cat类继承Animal类")]),n("li",null,[n("p",null,"接口的实现类"),n("p",null,[a("要么重写接口中的所有抽象方法，要么本身是抽象类。"),n("strong",null,"接口中的所有方法默认被abstract修饰。")])]),n("li",null,[n("p",null,"接口类中的成员变量"),n("p",null,[a("1."),n("strong",null,"成员变量只能是常量，默认被public static final 修饰， 可以通过接口名直接访问。")]),n("p",null,"2.接口类没有构造方法，如果有子类继承接口类，则该子类的super()方法调用的是Object类的构造方法。"),n("p",null,"3.接口类的成员方法只能是抽象方法，默认被public abstract 修饰，且变量和方法不能用private和protected修饰。")]),n("li",null,[n("p",null,"类和接口的关系"),n("p",null,"1.类和类的关系"),n("p",null,"  继承关系，只能单继承，但是可以多层继承"),n("p",null,"2.类和接口的关系"),n("p",null,"  实现关系；可以单实现，也可以多实现；还可以在继承一个类的同时实现多个接口"),n("p",null,"  例：public class InterImpl implements Inter1,Inter2,Inter3"),n("p",null,"3.接口和接口的关系"),n("p",null,"  继承关系，可以单继承，也可以多继承"),n("p",null,"  例：public interface Inter3 extends Inter1,Inter2")]),n("li",null,[n("p",null,"接口中的默认方法(Java8新增)"),n("p",null,"1.定义格式"),n("p",null,[a("  "),n("code",null,"public default 返回值类型 方法名称(参数列表) { }")]),n("p",null,[a("  例：public default void show() { 可以定义具体的实现 }   //"),n("strong",null,"public关键字可以省略")]),n("p",null,"2.特点"),n("p",null,[a("  1."),n("strong",null,"默认方法不是抽象方法，所以不强制重写，但也可以被子类继承、重写，重写时去掉default关键字")]),n("p",null,"  2.如果有个类继承了多个接口，且这些接口中有重名的默认方法，则该类必须重写该方法。可以有重名的抽象方法。")]),n("li",null,[n("p",null,"接口中的静态方法"),n("p",null,"1.定义格式"),n("p",null,"  public static 返回值类型 方法名 (参数列表)"),n("p",{具体实现:""},"  例：public static void show()"),n("p",null,"2.特点"),n("p",null,[a("  1."),n("strong",null,"静态方法只能通过接口名调用，不能通过实现类或对象名调用。")]),n("p",null,"  2.public可以省略，但static不能省略。"),n("p",null,[a("  3.因为静态方法只能通过接口名调用，所以"),n("strong",null,"即使类继承了多个接口，这些接口中也可以有重名的静态方法。")])]),n("li",null,[n("p",null,"私有方法"),n("p",null,"当两个默认方法或者静态方法中包含一段相同的代码时，就可以将这段代码封装成一个共性的方法，"),n("p",null,"而这个方法是不需要让别人使用的，因此用私有隐藏起来，所以Java9引入了私有方法."),n("p",null,"1.定义格式"),n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"private"),a(" 返回值类型 方法名 "),n("span",{class:"token punctuation"},"("),a("参数列表"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a("  "),n("span",{class:"token punctuation"},"}"),a(`

  例，`),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"show"),n("span",{class:"token punctuation"},"("),a(),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a("  "),n("span",{class:"token punctuation"},"}"),a(`

`),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token keyword"},"static"),a(" 返回值类型 方法名"),n("span",{class:"token punctuation"},"("),a("参数列表"),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a("  "),n("span",{class:"token punctuation"},"}"),a(`

  例，`),n("span",{class:"token keyword"},"private"),a(),n("span",{class:"token keyword"},"static"),a(),n("span",{class:"token keyword"},"void"),a(),n("span",{class:"token function"},"method"),n("span",{class:"token punctuation"},"("),a(),n("span",{class:"token punctuation"},")"),a(),n("span",{class:"token punctuation"},"{"),a("  "),n("span",{class:"token punctuation"},"}"),a(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])]),n("p",null,"2.特点"),n("p",null,[n("strong",null,"默认方法可以调用静态的私有方法和非静态的私有方法。")]),n("p",null,[n("strong",null,"静态方法只能调用静态的私有方法。")])])],-1),u=s(`<h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h3><ol><li><p>接口中的方法默认是抽象方法，但也可以定义默认方法和静态方法。</p></li><li><p>接口中的默认方法可以由接口的实现类直接调用，静态方法可以通过接口名直接调用。</p></li><li><p>抽象类中也可以定义默认方法和静态方法。</p></li><li><p>抽象类中的静态方法可以被继承类直接调用，默认方法只能通过实例化对象进行调用。</p></li></ol><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h2><p>在一个类中再定义一个类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>
         
     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>
          
     <span class="token punctuation">}</span>
      
 <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>内部类可以访问外部类的成员，包括私有的</p></li><li><p>外部类要访问内部类成员，必须创建对象</p></li></ol><p>成员内部类</p><p>  <strong>在类中定义一个类，可以看做外部类的成员</strong></p><p>  创建对象：外部类名.内部类名 对象名=外部类对象.内部类对象</p><p>    例：Outer.Inner a=new Outer().new Inner()   //前提是Inner的权限是public 不常使用</p><p>    <strong>一般是在外部类的成员方法中直接创建内部类的对象，然后调用内部类的方法。</strong></p><p>局部内部类</p><p>  <strong>在外部类的方法中再定义一个类</strong>，外界无法直接使用，需要在方法内部创建对象并使用</p><p>  该类可以直接访问外部类的成员，也可以访问方法内的局部成员变量。</p><p>​</p>`,15);function r(d,k){return e(),l("div",null,[p(" permalink: /    "),c,o,u])}const m=t(i,[["render",r],["__file","面向对象.html.vue"]]);export{m as default};
