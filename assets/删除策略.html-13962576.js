import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,a as n}from"./app-a89b456a.js";const p="/assets/image-20230426075422362-e6e0b5f1.png",i="/assets/image-20230426075432032-a098de79.png",r={},t=n('<h2 id="删除策略" tabindex="-1"><a class="header-anchor" href="#删除策略" aria-hidden="true">#</a> 删除策略</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>Redis是一种内存级数据库，所有数据均存放在内存中，<strong>内存中的数据可以通过TTL命令获取其状态</strong>。</p><p>TTL命令返回值：</p><p>​  -1：代表永久有效的数据</p><p>​  -2：已经过期的数据 或 被删除的数据 或 未定义的数据</p><p>​  一个具体的时间：具有时效性的数据</p><p><strong>过期的数据并不会立即删除，而是根据设置的策略执行。</strong></p><p>​ <img src="'+p+'" alt="image-20230426075422362" loading="lazy"></p><h3 id="如何判断数据是否过期" tabindex="-1"><a class="header-anchor" href="#如何判断数据是否过期" aria-hidden="true">#</a> 如何判断数据是否过期</h3><p>Redis 通过一个叫做过期字典(可以看作是 hash 表)的东西来保存数据过期的时间。</p><p>过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间(毫秒精度的 UNIX 时间戳)。</p><p>​ <img src="'+i+`" alt="image-20230426075432032" style="zoom:60%;"></p><p>​ 过期字典是存储在 redisDb 这个结构里的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>       <span class="token comment">//数据库键空间，保存着数据库中所有键值对</span>
    
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>   <span class="token comment">// 过期字典，保存着键的过期时间      </span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数据删除策略" tabindex="-1"><a class="header-anchor" href="#数据删除策略" aria-hidden="true">#</a> 数据删除策略</h3><h4 id="_1-定时删除" tabindex="-1"><a class="header-anchor" href="#_1-定时删除" aria-hidden="true">#</a> <strong>1.定时删除</strong></h4><p>​ (1)创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p><p>​ (2)优点：节约内存，到时就删除，快速释放掉不必要的内存占用</p><p>​ (3)缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</p><p>​ (4)总结：<strong>用处理器性能换取存储空间(用时间换空间)</strong></p><h4 id="_2-惰性删除" tabindex="-1"><a class="header-anchor" href="#_2-惰性删除" aria-hidden="true">#</a> <strong>2.惰性删除</strong></h4><p>​ (1)数据到达过期时间，不做处理。等到下次访问该数据时：</p><p>​    如果未过期，返回数据</p><p>​    发现已过期，删除记录，并返回不存在</p><p>​ (2)优点：节约CPU性能，发现必须删除的时候才删除</p><p>​ (3)缺点：内存压力很大，出现长期占用内存的数据</p><p>​ (4)总结：<strong>用存储空间换取处理器性能 (用空间换时间)</strong></p><h4 id="_3-定期删除" tabindex="-1"><a class="header-anchor" href="#_3-定期删除" aria-hidden="true">#</a> <strong>3.定期删除</strong></h4><p>​ (1)Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p><p>​ (2)每秒钟执行server.hz次serverCron() ----&gt;databaseCron( ) ---&gt;activeExpireCycle( )</p><p>​ (3)activeExpireCycle函数对每个<code>expires[*]</code>逐一检测，每次执行250ms/server.hz。<code>expires[*]</code>代表任意一个数据库。</p><p>​ (4)对某个数据库进行检测时，随机挑选W个key检测</p><p>​   如果key超时，删除key</p><p>​   如果一轮中删除的key的数量&gt;W*25%，循环该过程</p><p>​   如果一轮中删除的key的数量≤W*25%，检查下一个<code>expires[*]</code>，从0-15循环</p><p>​     W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</p><p>​ (5)参数current_db用于记录activeExpireCycle函数进入哪个数据库执行</p><p>​ (6)如果activeExpireCycle函数执行时间到期，下次从current_db开始继续向下执行</p><p>特点:</p><ol><li><p><strong>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</strong></p></li><li><p>CPU性能占用设置有峰值，检测频度可自定义设置</p></li><li><p>内存压力不是很大，长期占用内存的冷数据会被持续清理</p></li><li><p>总结：<strong>周期性抽查存储空间(随机抽查，重点抽查)</strong></p></li></ol><h3 id="删除策略对比" tabindex="-1"><a class="header-anchor" href="#删除策略对比" aria-hidden="true">#</a> 删除策略对比</h3><ol><li><p>定时删除   节约内存，无占用    不分时段占用CPU资源，频度高      拿时间换空间</p></li><li><p>惰性删除   内存占用严重         延时执行，CPU利用率高            拿空间换时间</p></li><li><p>定期删除   内存定期随机清理    每秒花费固定的CPU资源维护内存     随机抽查，重点抽查</p></li></ol><h3 id="逐出算法" tabindex="-1"><a class="header-anchor" href="#逐出算法" aria-hidden="true">#</a> 逐出算法</h3><h4 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> <strong>定义</strong></h4><p>当新数据进入redis时，如果内存不足怎么办</p><ol><li><p>Redis使用内存存储数据，在执行每一个命令前，会调用 freeMemoryIfNeeded()检测内存是否充足。</p><p>如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前数据留出存储空间。</p><p><strong>清理数据的策略称为逐出算法或淘汰策略。</strong></p></li><li><p>逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。</p><p>当对所有数据尝试完毕后，仍然不能达到内存清理的要求，将出现错误信息。</p></li></ol><h4 id="相关配置" tabindex="-1"><a class="header-anchor" href="#相关配置" aria-hidden="true">#</a> <strong>相关配置</strong></h4><ol><li>maxmemory</li></ol><p>​   最大可使用内存，即占用物理内存的比例，默认为0，表示不限制。根据需求设定，通常设置在50%以上。</p><ol start="2"><li>maxmemory-samples</li></ol><p>​   每次选取待删除的数据的个数</p><p>​   选取数据时并不会全库扫描，这样将导致严重的性能消耗，降低读写性能。</p><p>​   因此采用随机获取数据的方式选出待检测删除数据</p><ol start="3"><li><p>maxmemory-policy</p><p>  达到最大内存后，对被挑选出来的数据进行删除的策略</p></li></ol><h4 id="驱逐策略" tabindex="-1"><a class="header-anchor" href="#驱逐策略" aria-hidden="true">#</a> <strong>驱逐策略</strong></h4><ol><li>检测易失数据（已设置过期时间的数据集--server.db[i].expires ）</li></ol><p>​   volatile-lru：挑选最后一次使用时间距现在较早的数据淘汰(长时间没有用过的数据)   LRU:least recently used</p><p>​   volatile-lfu：挑选最近使用次数最少的数据淘汰(规定时间内使用次数最少)   LFU:least frequently used</p><p>​   volatile-ttl：挑选将要过期的数据淘汰</p><p>​   volatile-random：任意选择数据淘汰</p><ol start="2"><li>检测全库数据 (所有数据集--server.db[i].dict)</li></ol><p>​   allkeys-lru：挑选最近最少使用的数据淘汰</p><p>​   allkeys-lfu：挑选最近使用次数最少的数据淘汰</p><p>​   allkeys-random：任意选择数据淘汰</p><ol start="3"><li>放弃数据驱逐</li></ol><p>​   no-enviction：禁止驱逐数据(4.0中默认策略)，当内存不足以容纳新数据时会引发错误OOM(out of memory)</p><p>​</p><p>​</p>`,69),l=[t];function o(d,c){return a(),s("div",null,l)}const m=e(r,[["render",o],["__file","删除策略.html.vue"]]);export{m as default};
