import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,f as o,a as t}from"./app-a89b456a.js";const p="/assets/image-20230426100359276-4b18844c.png",r="/assets/image-20230426100405714-0736d58a.png",i="/assets/image-20230426100412284-1705c419.png",n="/assets/image-20230426100419746-14f5eaa5.png",g="/assets/image-20230426100434253-9fda319d.png",l="/assets/image-20230426100443635-b3102835.png",c="/assets/image-20230426100449214-90aa806f.png",d="/assets/image-20230426100502522-29cd54eb.png",I="/assets/image-20230426100508861-12aa66e0.png",O="/assets/image-20230426100514274-0ce78e8d.png",h="/assets/image-20230426100520718-d8edbb48.png",m="/assets/image-20230426100536188-553f0134.png",_="/assets/image-20230426100547516-a765bfe1.png",f="/assets/image-20230617211545806-44ed797b.png",b="/assets/image-20230426100608037-b8f5b2b1.png",u="/assets/image-20230426100618968-637ceeef.png",N={},x=t('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>应用程序并不存在实质的IO过程，真正的IO过程是操作系统的事，这里把应用程序的IO操作分为两种：IO调用和IO执行。</p><p>IO调用是由进程发起，IO执行是操作系统的工作。因此，更准确些来说，此时所说的<strong>IO是应用程序对操作系统IO功能的一次触发，即IO调用。</strong></p><p>IO调用的目的是将进程的内部数据迁移到外部(输出)，或者是将外部数据迁移到进程内部(输入)。</p><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和 <strong>异步 I/O</strong>。</p><h2 id="阻塞和非阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞和非阻塞" aria-hidden="true">#</a> 阻塞和非阻塞</h2><p><strong>阻塞和非阻塞强调的是进程对于操作系统IO是否处于就绪状态的处理方式。</strong></p><p>进程的IO调用是否能得到立即执行是需要操作系统IO处于就绪状态的，对于读取数据的操作，如果操作系统IO处于</p><p>未就绪状态，<strong>当前进程或线程如果一直等待直到其就绪，该种IO方式为阻塞IO。</strong></p><p><strong>如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为非阻塞IO。</strong></p><p>所以对于非阻塞IO，编程时需要经常去轮询就绪状态。</p><h3 id="阻塞-blocking-i-o" tabindex="-1"><a class="header-anchor" href="#阻塞-blocking-i-o" aria-hidden="true">#</a> 阻塞(Blocking I/O)</h3><p>应用程序中，进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的进程一直处于等待状态 ，则此次IO操作为阻塞IO。</p><p>​ <img src="'+p+'" alt="image-20230426100359276" loading="lazy"></p><h3 id="非阻塞" tabindex="-1"><a class="header-anchor" href="#非阻塞" aria-hidden="true">#</a> 非阻塞</h3><p>内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。</p><p>​ <img src="'+r+'" alt="image-20230426100405714" loading="lazy"></p><p>非阻塞IO虽然相对于阻塞IO大幅提升了性能，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。</p><h2 id="io多路复用" tabindex="-1"><a class="header-anchor" href="#io多路复用" aria-hidden="true">#</a> IO多路复用</h2><h3 id="select-poll" tabindex="-1"><a class="header-anchor" href="#select-poll" aria-hidden="true">#</a> select/poll</h3><p>解决NIO的思路就是减少无效的系统调用，<strong>Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态</strong>，</p><p>当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。</p><p>换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。</p><p><strong>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</strong></p><p>​ <img src="'+i+'" alt="image-20230426100412284" loading="lazy"></p><p>​ 但是，select有一个限制，就是存在连接数限制，针对于此，又提出了<strong>poll。其与select相比，主要是解决了连接限制</strong>。</p><p>select/poll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：</p><p>​  1。用户空间和内核空间之间进行大量的数据拷贝</p><p>​  2。内核循环遍历IO状态，浪费CPU时间</p><p>换句话说，<strong>select/poll虽然减少了用户进程发起的系统调用，但内核的工作量只增不减</strong>。在高并发的情况下，内核的性能</p><p>问题依旧。所以<strong>select/poll的问题本质是：内核存在无效的循环遍历</strong>。</p><h3 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h3><figure><img src="'+n+'" alt="image-20230426100419746" tabindex="0" loading="lazy"><figcaption>image-20230426100419746</figcaption></figure><p>​ epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞</p><p>​ 用户进程，等待IO事件。</p><p>​ <img src="'+g+'" alt="image-20230426100434253" loading="lazy"></p><h2 id="信号驱动i-o" tabindex="-1"><a class="header-anchor" href="#信号驱动i-o" aria-hidden="true">#</a> 信号驱动I/O</h2><p>信号驱动IO与BIO和NIO最大的区别就在于，<strong>在IO执行的数据准备阶段，不会阻塞用户进程。</strong></p><p>当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中</p><p>​ 的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用</p><p>​ recvfrom，去查收数据。</p><p>​ <img src="'+l+'" alt="image-20230426100443635" loading="lazy"></p><p>​ <img src="'+c+'" alt="image-20230426100449214" loading="lazy"></p><p>乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间</p><p>​ 这个阶段，用户进程还是被阻塞的。</p><p>综上，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。</p><h2 id="异步i-o" tabindex="-1"><a class="header-anchor" href="#异步i-o" aria-hidden="true">#</a> 异步I/O</h2><p>​ 异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到</p><p>用户进程缓冲区，然后发送信号告诉用户进程<strong>IO操作执行完毕。</strong></p><p><strong>与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕。</strong></p><p>​ <img src="'+d+'" alt="image-20230426100502522" loading="lazy"></p><p>​ 所以，<strong>之所以称为异步IO，取决于IO执行的第二阶段是否阻塞</strong>。<strong>因此BIO，NIO和SIGIO均为同步IO。</strong></p><p>​ <img src="'+I+'" alt="image-20230426100508861" loading="lazy"></p><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h2><p>​ <img src="'+O+'" alt="image-20230426100514274" loading="lazy"></p><h2 id="java中3种常见-io-模型" tabindex="-1"><a class="header-anchor" href="#java中3种常见-io-模型" aria-hidden="true">#</a> Java中3种常见 IO 模型</h2><h3 id="bio-blocking-i-o" tabindex="-1"><a class="header-anchor" href="#bio-blocking-i-o" aria-hidden="true">#</a> BIO(Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，<strong>应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</strong></p><p>​ <img src="'+h+'" alt="image-20230426100520718" style="zoom:80%;"></p><p>​ 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接时，传统的 BIO 模型是无能为力的。</p><h3 id="nio" tabindex="-1"><a class="header-anchor" href="#nio" aria-hidden="true">#</a> NIO</h3><p><strong>(Non-blocking/New I/O)</strong></p><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> ， <code>Selector</code>，<code>Buffer</code> 等抽象类。</p><p>NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。</p><p><strong>它是支持面向缓冲的，基于通道的 I/O 操作方法。</strong> 对于高负载、高并发的(网络)应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>​ <img src="'+m+'" alt="image-20230426100536188" style="zoom:67%;"></p><p>​ 同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，</p><p>​ 线程依然是阻塞的，直到内核把数据拷贝到用户空间。</p><p>​ 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>​ 但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程十分消耗 CPU 资源。</strong></p><p>​ <img src="'+_+'" alt="image-20230426100547516" style="zoom:67%;"></p><p>​ IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程</p><p>​ 再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎所有的操作系统上都支持。</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p>​ <strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>​ Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。</p><p>​ 通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p>​ <img src="'+f+'" alt="image-20230617211545806" loading="lazy"></p><h3 id="aio" tabindex="-1"><a class="header-anchor" href="#aio" aria-hidden="true">#</a> AIO</h3><p>Asynchronous I/O，AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2，它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，</p><p>操作系统会通知相应的线程继续后续的操作。</p><p>​ <img src="'+b+'" alt="image-20230426100608037" style="zoom:67%;"></p><p>​</p><h3 id="对比-1" tabindex="-1"><a class="header-anchor" href="#对比-1" aria-hidden="true">#</a> 对比</h3><p>​ <img src="'+u+'" alt="image-20230426100618968" style="zoom:50%;"></p>',88);function y(z,v){return e(),s("div",null,[o(" permalink: /    "),x])}const S=a(N,[["render",y],["__file","IO模型.html.vue"]]);export{S as default};
