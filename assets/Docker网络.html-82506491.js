import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,a as s}from"./app-a89b456a.js";const r="/assets/image-20230426095811966-d3e00e69.png",i="/assets/image-20230426095826124-cb3cfd0c.png",t="/assets/image-20230426095831706-c86cb837.png",o="/assets/image-20230426095836964-a551efa1.png",c={},l=s(`<h2 id="docker网络" tabindex="-1"><a class="header-anchor" href="#docker网络" aria-hidden="true">#</a> Docker网络</h2><p><strong>docker启动后会产生一个名为docker0的虚拟网桥，默认创建三大网络模式。(仅主机模式、NAT模式、桥接模式)</strong></p><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0.docker network --help     查看所有命令

1.docker network ls         查看所有网络

2.docker network inspect +网络名称   查看网络的详细信息

3.docker network rm  +网络名称    删除网络
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h3><p>​ 容器间的互联和通信以及端口映射。</p><p>​ 容器IP变动时候可以通过服务名直接进行网络通信而不受到影响。</p><h3 id="网络模式" tabindex="-1"><a class="header-anchor" href="#网络模式" aria-hidden="true">#</a> 网络模式</h3><p>​ <img src="`+r+'" alt="image-20230426095811966" style="zoom:80%;"></p><p><strong>注意：</strong></p><ol><li><p>bridge、host、none 都是使用 --network 模式名指定</p></li><li><p>container 使用 --network container:容器名称 或 容器ID 指定</p></li></ol><h4 id="bridge" tabindex="-1"><a class="header-anchor" href="#bridge" aria-hidden="true">#</a> <strong>bridge</strong></h4><ol><li><p>Docker 服务默认会创建一个 docker0 网桥(其上有一个 docker0 内部接口)，该桥接网络的名称为docker0，它在内核层</p><p>连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p><strong>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</strong></p></li><li><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段</p><p>分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。</p><p><strong>因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</strong></p></li><li><p>docker run 的时候，没有指定network的话默认使用的网桥模式就是bridge，使用的就是docker0。</p><p>在宿主机执行ifconfig，就可以看到docker0和自己create的network eth0，eth1，eth2……代表网卡一，网卡二，</p><p>网卡三....，lo代表127.0.0.1，即localhost，inet addr用来表示网卡的IP地址。</p></li><li><p>网桥docker0创建一对对等虚拟设备接口一个叫veth，另一个叫eth0，成对匹配。</p></li></ol><p>​   4.1 整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫veth，在本地主机和容器内分别创建</p><p>​       一个虚拟接口，并让他们彼此联通（这样一对接口叫veth pair）；</p><p>​   4.2 每个容器实例内部也有一块网卡，每个接口叫eth0；</p><p>​   4.3 docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。</p><p>通过上述，将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下,会从这个网关下各自拿到分配的ip，此时两个容器的网络是互通的。</p><p>​ <img src="'+i+'" alt="image-20230426095826124" loading="lazy"></p><h4 id="host" tabindex="-1"><a class="header-anchor" href="#host" aria-hidden="true">#</a> <strong>host</strong></h4><ol><li><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p></li><li><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。</p></li></ol><p>​   容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><p>​ <img src="'+t+'" alt="image-20230426095831706" loading="lazy"></p><h4 id="none" tabindex="-1"><a class="header-anchor" href="#none" aria-hidden="true">#</a> <strong>none</strong></h4><p>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，</p><p>只有一个lo，需要我们自己为Docker容器添加网卡、配置IP等。</p><h4 id="container" tabindex="-1"><a class="header-anchor" href="#container" aria-hidden="true">#</a> <strong>container</strong></h4><p><strong>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享</strong>。新创建的容器不会创建自己的网卡，</p><p>配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><p>​ <img src="'+o+`" alt="image-20230426095836964" style="zoom:80%;"></p><h3 id="自定义网络" tabindex="-1"><a class="header-anchor" href="#自定义网络" aria-hidden="true">#</a> 自定义网络</h3><p>自定义网络默认使用的是桥接网络</p><ol><li>新建自定义网络</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker network create vkls_network
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>新建容器加入上一步新建的自定义网络</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8081</span>:8080 <span class="token parameter variable">--network</span> vkls_network  <span class="token parameter variable">--name</span> tomcat81 billygoo/tomcat8-jdk8

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8082</span>:8080 <span class="token parameter variable">--network</span> vkls_network  <span class="token parameter variable">--name</span> tomcat82 billygoo/tomcat8-jdk8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用服务名互相ping</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat81 <span class="token function">bash</span>

  <span class="token function">ping</span> tomcat82
  
  
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> tomcat82 <span class="token function">bash</span>
 
  <span class="token function">ping</span> tomcat81
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结论：自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</p>`,39),d=[l];function p(h,m){return a(),n("div",null,d)}const u=e(c,[["render",p],["__file","Docker网络.html.vue"]]);export{u as default};
