import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,a as t}from"./app-a89b456a.js";const e="/assets/image-20230731215037940-ebbd1bb3.png",p="/assets/image-20230802171329496-eebf6b0e.png",i={},l=t(`<h2 id="线程状态" tabindex="-1"><a class="header-anchor" href="#线程状态" aria-hidden="true">#</a> 线程状态</h2><h3 id="_5种状态" tabindex="-1"><a class="header-anchor" href="#_5种状态" aria-hidden="true">#</a> 5种状态</h3><p>五种状态的划分主要是从操作系统的层面进行划分的</p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就能运行。</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行。</p><p>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，这会导致上下文切换。</p></li><li><p>阻塞状态</p><ol><li><p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态。</p></li><li><p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。</p></li><li><p>与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就不会分配时间片。</p></li></ol></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。</p></li></ol><h3 id="_6种状态" tabindex="-1"><a class="header-anchor" href="#_6种状态" aria-hidden="true">#</a> 6种状态</h3><p>在 API <code>java.lang.Thread.State</code> 中给出了六种线程状态：</p><h4 id="new" tabindex="-1"><a class="header-anchor" href="#new" aria-hidden="true">#</a> <strong>NEW</strong></h4><p>NEW 跟五种状态里的初始状态是一个意思，<strong>处于NEW状态的线程尚未启动，即，还没有调用Thread实例的start()方法。</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">testStateNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 NEW</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p><ol><li><p><strong>不能多次调用同⼀个线程的start()方法</strong></p></li><li><p><strong>假如⼀个线程执行完毕(此时处于TERMINATED状态)，也不能再次调用这个线程的start()⽅法。</strong></p><p>因为在调用⼀次start()之后，threadStatus的值会改变（threadStatus !=0），此时再次调用start()方法会抛出</p><p>IllegalThreadStateException异常。</p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus ！<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>

    <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="runnable" tabindex="-1"><a class="header-anchor" href="#runnable" aria-hidden="true">#</a> <strong>RUNNABLE</strong></h4><p>Runnable 是当调用了 <code>start()</code> 方法之后的状态。</p><p><strong>Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【就绪状态】、【运行状态】和【io阻塞状态】。</strong></p><p>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）。</p><h4 id="blocked" tabindex="-1"><a class="header-anchor" href="#blocked" aria-hidden="true">#</a> <strong>BLOCKED</strong></h4><p><strong>BLOCKED，WAITING，TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分。</strong></p><p>阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</p><h4 id="waiting" tabindex="-1"><a class="header-anchor" href="#waiting" aria-hidden="true">#</a> <strong>WAITING</strong></h4><p>等待状态。<strong>处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</strong></p><p>调用如下3个方法会使线程进入等待状态：</p><p>​  Object.wait()：使当前线程处于等待状态直到另⼀个线程唤醒它；</p><p>​  Thread.join()：等待某个线程执行完毕，底层调用的是Object实例的wait方法；</p><p>​  LockSupport.park()：除非获得调用许可，否则禁止当前线程进行线程调度。</p><h4 id="timed-waiting" tabindex="-1"><a class="header-anchor" href="#timed-waiting" aria-hidden="true">#</a> <strong>TIMED_WAITING</strong></h4><p>超时等待状态。线程等待⼀个具体的时间，时间到后会被自动唤醒。</p><p>调用如下方法会使线程进入超时等待状态：</p><p>​  Thread.sleep(long millis)：使当前线程睡眠指定时间；</p><p>​  Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过 notify()/notifyAll()唤醒；</p><p>​  Thread.join(long millis)：等待某个线程结束，最多等待millis毫秒，如果millis为0，则会⼀直等待；</p><p>​  LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁止当前线程进行线程调度，可以指定时间；</p><p>​  LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度，可以指定时间；</p><table><thead><tr><th style="text-align:center;">线程状态</th><th style="text-align:center;">导致状态发生条件</th></tr></thead><tbody><tr><td style="text-align:center;">NEW（新建）</td><td style="text-align:center;">线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td style="text-align:center;">Runnable（可运行）</td><td style="text-align:center;">线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td style="text-align:center;">Blocked（阻塞）</td><td style="text-align:center;">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td style="text-align:center;">Waiting（无限等待）</td><td style="text-align:center;">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td style="text-align:center;">Timed_Waiting （限期等待）</td><td style="text-align:center;">有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td style="text-align:center;">Teminated（结束）</td><td style="text-align:center;">run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><h3 id="状态转换" tabindex="-1"><a class="header-anchor" href="#状态转换" aria-hidden="true">#</a> 状态转换</h3><img src="`+e+'" alt="image-20230731215037940" style="zoom:80%;"><p>​ <img src="'+p+'" alt="image-20230802171329496" style="zoom:67%;"></p><p>1.如果线程拿到锁之后调用wait方法主动释放锁，则线程会从Runnable状态进入到Waiting状态</p><p>2.如果在Waiting状态的线程被其他线程通过notify方法唤醒的话，会重新竞争锁，如果竞争失败，则会进入Blocked状态。</p><p>3.调用wait方法的前提是获得了锁，如果没有获得锁而调用wait方法，则会抛出异常。</p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3>',41),o=[l];function c(r,d){return a(),s("div",null,o)}const h=n(i,[["render",c],["__file","线程状态.html.vue"]]);export{h as default};
