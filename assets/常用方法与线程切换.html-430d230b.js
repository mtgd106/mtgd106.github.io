const t=JSON.parse('{"key":"v-0c66b97a","path":"/posts/note/Concurrency/Java%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2.html","title":"常用方法与线程切换","lang":"zh-CN","frontmatter":{"title":"常用方法与线程切换","author":{"name":"北斗星司"},"category":["并发编程"],"tag":["线程Thread"],"date":"2023-10-23T15:08:32.000Z","icon":"file","description":"Thread类常用方法 方法 说明 public void start() 启动一个新线程，Java虚拟机调用此线程的 run 方法 public void run() 线程启动后调用该方法 public void setName(String name) 给当前线程取名字 public void getName() 获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main public static Thread currentThread() 获取当前线程对象，即该代码在哪个线程中执行则返回哪个线程 public static void sleep(long time) 让当前线程休眠多少毫秒再继续执行 Thread.sleep(0) : 让操作系统立刻重新进行一次 CPU 竞争 public static native void yield() 提示线程调度器让出当前线程对 CPU 的使用 public final int getPriority() 返回此线程的优先级 public final void setPriority(int priority) 更改此线程的优先级，常用 1 5 10 public void interrupt() 中断这个线程 public static boolean interrupted() 判断当前线程是否被打断，清除打断标记 public boolean isInterrupted() 判断当前线程是否被打断，不清除打断标记 public final void join() 等待这个线程结束 调用join()方法不会释放锁，会⼀直等待这个线程执行完毕 public final void join(long millis) 等待这个线程结束，最多等待 millis 毫秒，0 意味着永远等待 public final native boolean isAlive() 判断线程是否存活（还没有运行完毕） public final void setDaemon(boolean on) 将此线程标记为守护线程或用户线程","head":[["meta",{"property":"og:url","content":"https://mtgd106.github.io/posts/note/Concurrency/Java%E7%BA%BF%E7%A8%8B/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2.html"}],["meta",{"property":"og:site_name","content":"北斗星司"}],["meta",{"property":"og:title","content":"常用方法与线程切换"}],["meta",{"property":"og:description","content":"Thread类常用方法 方法 说明 public void start() 启动一个新线程，Java虚拟机调用此线程的 run 方法 public void run() 线程启动后调用该方法 public void setName(String name) 给当前线程取名字 public void getName() 获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main public static Thread currentThread() 获取当前线程对象，即该代码在哪个线程中执行则返回哪个线程 public static void sleep(long time) 让当前线程休眠多少毫秒再继续执行 Thread.sleep(0) : 让操作系统立刻重新进行一次 CPU 竞争 public static native void yield() 提示线程调度器让出当前线程对 CPU 的使用 public final int getPriority() 返回此线程的优先级 public final void setPriority(int priority) 更改此线程的优先级，常用 1 5 10 public void interrupt() 中断这个线程 public static boolean interrupted() 判断当前线程是否被打断，清除打断标记 public boolean isInterrupted() 判断当前线程是否被打断，不清除打断标记 public final void join() 等待这个线程结束 调用join()方法不会释放锁，会⼀直等待这个线程执行完毕 public final void join(long millis) 等待这个线程结束，最多等待 millis 毫秒，0 意味着永远等待 public final native boolean isAlive() 判断线程是否存活（还没有运行完毕） public final void setDaemon(boolean on) 将此线程标记为守护线程或用户线程"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"北斗星司"}],["meta",{"property":"article:tag","content":"线程Thread"}],["meta",{"property":"article:published_time","content":"2023-10-23T15:08:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常用方法与线程切换\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-23T15:08:32.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"北斗星司\\"}]}"]]},"headers":[{"level":2,"title":"Thread类常用方法","slug":"thread类常用方法","link":"#thread类常用方法","children":[{"level":3,"title":"start()和run()方法","slug":"start-和run-方法","link":"#start-和run-方法","children":[]},{"level":3,"title":"sleep()和yield()","slug":"sleep-和yield","link":"#sleep-和yield","children":[]},{"level":3,"title":"线程优先级","slug":"线程优先级","link":"#线程优先级","children":[]},{"level":3,"title":"join方法","slug":"join方法","link":"#join方法","children":[]}]},{"level":2,"title":"线程上下文切换","slug":"线程上下文切换","link":"#线程上下文切换","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.48,"words":1496},"filePathRelative":"posts/note/Concurrency/Java线程/常用方法与线程切换.md","localizedDate":"2023年10月23日","excerpt":"<h2> Thread类常用方法</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>方法</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>public void start()</td>\\n<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>\\n</tr>\\n<tr>\\n<td>public void run()</td>\\n<td>线程启动后调用该方法</td>\\n</tr>\\n<tr>\\n<td>public void setName(String name)</td>\\n<td>给当前线程取名字</td>\\n</tr>\\n<tr>\\n<td>public void getName()</td>\\n<td>获取当前线程的名字  线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>\\n</tr>\\n<tr>\\n<td>public static Thread currentThread()</td>\\n<td>获取当前线程对象，即该代码在哪个线程中执行则返回哪个线程</td>\\n</tr>\\n<tr>\\n<td>public static void sleep(long time)</td>\\n<td>让当前线程休眠多少毫秒再继续执行  <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>\\n</tr>\\n<tr>\\n<td>public static native void yield()</td>\\n<td>提示线程调度器让出当前线程对 CPU 的使用</td>\\n</tr>\\n<tr>\\n<td>public final int getPriority()</td>\\n<td>返回此线程的优先级</td>\\n</tr>\\n<tr>\\n<td>public final void setPriority(int priority)</td>\\n<td>更改此线程的优先级，常用 1 5 10</td>\\n</tr>\\n<tr>\\n<td>public void interrupt()</td>\\n<td>中断这个线程</td>\\n</tr>\\n<tr>\\n<td>public static boolean interrupted()</td>\\n<td>判断当前线程是否被打断，清除打断标记</td>\\n</tr>\\n<tr>\\n<td>public boolean isInterrupted()</td>\\n<td>判断当前线程是否被打断，不清除打断标记</td>\\n</tr>\\n<tr>\\n<td>public final void join()</td>\\n<td>等待这个线程结束  <strong>调用join()方法不会释放锁</strong>，会⼀直等待这个线程执行完毕</td>\\n</tr>\\n<tr>\\n<td>public final void join(long millis)</td>\\n<td>等待这个线程结束，最多等待 millis 毫秒，0 意味着永远等待</td>\\n</tr>\\n<tr>\\n<td>public final native boolean isAlive()</td>\\n<td>判断线程是否存活（还没有运行完毕）</td>\\n</tr>\\n<tr>\\n<td>public final void setDaemon(boolean on)</td>\\n<td>将此线程标记为守护线程或用户线程</td>\\n</tr>\\n</tbody>\\n</table>","copyright":{"author":"北斗星司"},"autoDesc":true}');export{t as data};
