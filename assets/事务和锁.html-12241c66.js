import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,a as i}from"./app-a89b456a.js";const p="/assets/image-20230426075157332-74e269d6.png",t="/assets/image-20230426075215215-a3816bdf.png",r="/assets/image-20231102180701442-7d15ccb4.png",n="/assets/image-20230426075232274-df3b8361.png",o={},d=i('<h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><ol><li><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。</p><p>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>redis事务就是一个 命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。</p><p>当执行时，一次性按照添加命令的顺序依次执行，中间不会被打断或者干扰。</p><p>即，<strong>一个队列中，一次性、顺序性、排他性的执行一系列命令</strong>。</p></li><li><p><strong>Redis事务的主要作用就是串联多个命令防止别的命令插队。</strong></p></li></ol><h3 id="操作" tabindex="-1"><a class="header-anchor" href="#操作" aria-hidden="true">#</a> 操作</h3><p><strong>multi</strong></p><p>​  设定事务的开始位置，执行该指令后，后续的所有指令都加入到事务中，直到执行exec指令。</p><p>  加入事务的命令只是暂时进入到任务队列中，并没有立即执行，只有遇到exec指令时才开始执行，</p><p>  执行完毕后返回每条指令的执行结果。</p><p><strong>exec</strong></p><p>  设定事务的结束位置，同时开始执行上面提交的事务。与multi成对出现，成对使用。</p><p><strong>discard</strong></p><p>  终止当前事务的定义，发生在multi之后，exec之前。</p><h3 id="命令特性" tabindex="-1"><a class="header-anchor" href="#命令特性" aria-hidden="true">#</a> 命令特性</h3><ol><li><p>从输入Multi指令开始，输入的命令都会依次进入到命令队列中，但不会执行，直到输入Exec后，Redis才会将之前</p><p>命令队列中的命令依次执行。进入队列的过程中可以通过使用discard指令来放弃组队。</p></li></ol><p>​ <img src="'+p+'" alt="image-20230426075157332" style="zoom:80%;"></p><ol start="2"><li><p>在定义事务的过程中，如果所输入的命令存在格式错误(例如：set 命令只有一个参数），则整个事务中的所有命令</p><p>都不会执行，包括正确的命令也不会执行。</p></li><li><p>如果定义事务的过程中，命令格式正确，但无法正确的执行(例：对list进行incr操作)，则能够正确运行的命令会执行，</p><p>无法执行的命令不会被执行。且已经执行完的命令不会对数据进行自动回滚，需要程序员自己在代码中实现回滚。</p></li><li><p><strong>如果在创建事务的过程中，试图在事务中修改的变量在另一个终端被修改了，则另一个终端的操作是有效的。</strong></p></li></ol><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><h3 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> 悲观锁</h3><p>悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候</p><p>都会上锁，这样别人想拿这个数据就会被block直到它拿到锁。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> 乐观锁</h3><p>乐观锁(Optimistic Lock)，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下</p><p>在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><p>乐观锁<strong>适用于多读的应用类型</strong>，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p><h3 id="监视锁" tabindex="-1"><a class="header-anchor" href="#监视锁" aria-hidden="true">#</a> 监视锁</h3><p>watch key1 [key2...]</p><p>​ 在执行multi之前，先执行watch key1 [key2]，可以监视一个(或多个) key ，如果在事务执行之前所监视的key被其他命令</p><p>​ 所改动，那么事务将会被打断。</p><p>​ 即，<strong>对 key添加监视锁，如果执行exec之前或事务执行之前key发生了变化，则终止事务的执行。</strong></p><p>​ <strong>没开始的就不要开始了，正在进行的立刻停止</strong>。</p><p>​ 使用unwatch可以取消对所有key的监视，如果在执行 watch 命令后，exec 或discard 命令先被执行了的话，就不需要</p><p>  再执行unwatch了。</p><p><strong>watch命令的不同使用：</strong></p><p>1.同一个session中，如果watch监视的key在multi之前被修改，那么该事务不会执行。</p><p>​ <img src="'+t+'" alt="image-20230426075215215" loading="lazy"></p><ol start="2"><li><p>同一个session中，如果watch监视的key在事务内部被修改，则事务可以执行。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>同一个session中，watch监视的key在事务内部被修改，但是在事务提交之前被其他 session 修改，则事务失败。</p><p>​ <img src="'+n+'" alt="image-20230426075232274" loading="lazy"></p></li></ol><p><strong>结论：</strong></p><p>  WATCH 操作只是 session 级别的，不会影响其他 session，在同一个 session 中，对于同一个 Key ，在事务执行之前</p><p>  最多只能加一个 WATCH，<strong>WATCH监视的 Key 在事务内部被修改，无论这个事务是否执行成功，这个Key 上的WATCH</strong></p><p>  <strong>都会失效。</strong></p><h3 id="事务的三特性" tabindex="-1"><a class="header-anchor" href="#事务的三特性" aria-hidden="true">#</a> 事务的三特性</h3><ol><li>单独的隔离操作</li></ol><p>​   事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><ol start="2"><li>没有隔离级别的概念</li></ol><p>​   队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p><ol start="3"><li>不保证原子性</li></ol><p>​   事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p><h3 id="解决事务缺陷" tabindex="-1"><a class="header-anchor" href="#解决事务缺陷" aria-hidden="true">#</a> 解决事务缺陷</h3><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。</p><p>可以利用 Lua 脚本批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，减小了网络开销</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。</p><p>因此，严格来说的话，<strong>通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的</strong>。</p><p>​ <strong>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</strong></p>',55),c=[d];function l(h,g){return a(),s("div",null,c)}const _=e(o,[["render",l],["__file","事务和锁.html.vue"]]);export{_ as default};
