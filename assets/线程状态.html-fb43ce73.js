const e=JSON.parse('{"key":"v-cd48f60a","path":"/posts/note/Concurrency/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.html","title":"线程状态","lang":"zh-CN","frontmatter":{"title":"线程状态","author":{"name":"北斗星司"},"category":["并发编程"],"tag":["线程Thread"],"date":"2023-10-23T15:08:32.000Z","icon":"file","description":"线程状态 5种状态 五种状态的划分主要是从操作系统的层面进行划分的 初始状态，仅仅是在语言层面上创建了线程对象，即Thead thread = new Thead();，还未与操作系统线程关联 可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就能运行。 运行状态，指线程获取了CPU时间片，正在运行。 当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，这会导致上下文切换。 阻塞状态 如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态。 等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。 与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就不会分配时间片。 终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。","head":[["meta",{"property":"og:url","content":"https://mtgd106.github.io/posts/note/Concurrency/Java%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.html"}],["meta",{"property":"og:site_name","content":"北斗星司"}],["meta",{"property":"og:title","content":"线程状态"}],["meta",{"property":"og:description","content":"线程状态 5种状态 五种状态的划分主要是从操作系统的层面进行划分的 初始状态，仅仅是在语言层面上创建了线程对象，即Thead thread = new Thead();，还未与操作系统线程关联 可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就能运行。 运行状态，指线程获取了CPU时间片，正在运行。 当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，这会导致上下文切换。 阻塞状态 如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态。 等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。 与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就不会分配时间片。 终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"北斗星司"}],["meta",{"property":"article:tag","content":"线程Thread"}],["meta",{"property":"article:published_time","content":"2023-10-23T15:08:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程状态\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-23T15:08:32.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"北斗星司\\"}]}"]]},"headers":[{"level":2,"title":"线程状态","slug":"线程状态","link":"#线程状态","children":[{"level":3,"title":"5种状态","slug":"_5种状态","link":"#_5种状态","children":[]},{"level":3,"title":"6种状态","slug":"_6种状态","link":"#_6种状态","children":[]},{"level":3,"title":"状态转换","slug":"状态转换","link":"#状态转换","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.04,"words":1407},"filePathRelative":"posts/note/Concurrency/Java线程/线程状态.md","localizedDate":"2023年10月23日","excerpt":"<h2> 线程状态</h2>\\n<h3> 5种状态</h3>\\n<p>五种状态的划分主要是从操作系统的层面进行划分的</p>\\n<ol>\\n<li>\\n<p>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</p>\\n</li>\\n<li>\\n<p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就能运行。</p>\\n</li>\\n<li>\\n<p>运行状态，指线程获取了CPU时间片，正在运行。</p>\\n<p>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，这会导致上下文切换。</p>\\n</li>\\n<li>\\n<p>阻塞状态</p>\\n<ol>\\n<li>\\n<p>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态。</p>\\n</li>\\n<li>\\n<p>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】。</p>\\n</li>\\n<li>\\n<p>与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就不会分配时间片。</p>\\n</li>\\n</ol>\\n</li>\\n<li>\\n<p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。</p>\\n</li>\\n</ol>","copyright":{"author":"北斗星司"},"autoDesc":true}');export{e as data};
