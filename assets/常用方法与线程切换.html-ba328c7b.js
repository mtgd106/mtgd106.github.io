import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,a as e}from"./app-a89b456a.js";const i={},s=e(`<h2 id="thread类常用方法" tabindex="-1"><a class="header-anchor" href="#thread类常用方法" aria-hidden="true">#</a> Thread类常用方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，即该代码在哪个线程中执行则返回哪个线程</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束 <strong>调用join()方法不会释放锁</strong>，会⼀直等待这个线程执行完毕</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程结束，最多等待 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>判断线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><h3 id="start-和run-方法" tabindex="-1"><a class="header-anchor" href="#start-和run-方法" aria-hidden="true">#</a> start()和run()方法</h3><p>  <strong>如果线程直接调用 run( )方法，则该线程的代码其实还是在主线程中执行的，并没有启动新的线程。</strong></p><p>  如果使用 start( )方法则可以启动新的线程，通过新的线程间接执行重写的 <code>run()</code>方法中的代码。</p><p>  当调用start方法后，线程状态会由“NEW”变为&quot;RUNNABLE&quot;，如果再次调用start方法则会</p><p>   抛出异常：illegalThreadStateException。</p><p>  <strong>run方法中的异常不能抛出，只能try...catch。</strong></p><h3 id="sleep-和yield" tabindex="-1"><a class="header-anchor" href="#sleep-和yield" aria-hidden="true">#</a> sleep()和yield()</h3><p><strong>sleep( )：</strong></p><ol><li><p><strong>调用 sleep方法会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）。</strong></p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程就会抛出 <code>InterruptedException</code>异常。</p><p>注意：这里打断的是正在休眠的线程，而不是其它状态的线程</p></li><li><p>睡眠结束后的线程未必会立刻得到执行，需要和其他线程竞争CPU。</p></li><li><p><strong>线程sleep的过程中，不会释放锁。</strong></p></li><li><p>建议用 TimeUnit 的 sleep( )代替 Thread 的 sleep( )来获得更好的可读性。</p></li></ol><p><strong>yield( )：</strong></p><ol><li><p><strong>调用 yield方法 会让当前线程从 Running 进入 Runnable状态(就绪)，然后CPU调度执行其它线程。</strong></p></li><li><p>具体的实现依赖于操作系统的任务调度器(可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)。</p></li><li><p><strong>调用yield方法，会释放CPU，但不会释放锁资源。</strong></p></li></ol><p><strong>小结：</strong></p><p>  yield使cpu调用其它线程，但是cpu可能会再次分配时间片给该线程 ；</p><p>  而sleep需要等过了休眠时间之后才有可能被分配cpu时间片。</p><h3 id="线程优先级" tabindex="-1"><a class="header-anchor" href="#线程优先级" aria-hidden="true">#</a> 线程优先级</h3><p>Java中线程优先级可以指定，范围是1~10。但是并不是所有的操作系统都支持10级优先级的划分(比如有些操作系统</p><p>只支持3级划分：低，中，高），Java只是给操作系统⼀个优先级的参考值，线程最终在操作系统的优先级是多少还是</p><p>由操作系统决定。</p><p>Java默认的线程优先级为5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。</p><p>通常情况下，高优先级的线程将会比低优先级的线程有更高的几率得到执行。</p><p>使用Thread类的setPriority() 方法来设定线程的优先级。</p><ol><li><p><strong>Java程序中对线程所设置的优先级只是给操作系统⼀个建议，操作系统不⼀定会采纳。</strong></p><p><strong>真正的调用顺序，是由操作系统的线程调度算法决定的。</strong></p></li><li><p>如果某个线程优先级大于其所在线程组的最大优先级，那么该线程的优先级将会失效，以其所在线程组的优先级为准。</p></li></ol><h3 id="join方法" tabindex="-1"><a class="header-anchor" href="#join方法" aria-hidden="true">#</a> join方法</h3><p>​ public final void join()：等待这个线程结束。</p><p>​ 原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束    </span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p></li><li><p>当调用某个线程(t1)的 join 方法后，该线程(t1)抢占到 CPU 资源，就不再释放，直到线程执行完毕。</p></li></ul><h2 id="线程上下文切换" tabindex="-1"><a class="header-anchor" href="#线程上下文切换" aria-hidden="true">#</a> 线程上下文切换</h2><p><strong>Thread Context Switch</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码：</p><ul><li><p>线程的 cpu 时间片用完(每个线程轮流执行)</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</p></li><li><p>调用了阻塞类型的系统中断，比如请求IO、线程被阻塞。</p></li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是</p><p>程序计数器，它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p>`,35),p=[s];function d(o,r){return n(),a("div",null,p)}const u=t(i,[["render",d],["__file","常用方法与线程切换.html.vue"]]);export{u as default};
